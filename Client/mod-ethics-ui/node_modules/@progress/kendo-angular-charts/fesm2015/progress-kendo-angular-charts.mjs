/**-----------------------------------------------------------------------------------------
* Copyright © 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { isDevMode, Directive, Optional, Injectable, SimpleChange, TemplateRef, Component, ChangeDetectionStrategy, Input, ContentChild, ElementRef, ViewChild, ViewChildren, EventEmitter, Output, ContentChildren, LOCALE_ID, Inject, InjectionToken, NgModule } from '@angular/core';
import * as i8 from '@progress/kendo-angular-common';
import { isDocumentAvailable, ResizeSensorModule } from '@progress/kendo-angular-common';
import * as i4 from '@progress/kendo-angular-l10n';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { DateCategoryAxis, DateValueAxis, DomEventsBuilder as DomEventsBuilder$1, InstanceObserver, chartBaseTheme, Chart, StockChart, Sparkline } from '@progress/kendo-charts';
import { exportImage, exportSVG } from '@progress/kendo-drawing';
import { validatePackage } from '@progress/kendo-licensing';
import { Subject, BehaviorSubject, combineLatest } from 'rxjs';
import { auditTime, tap } from 'rxjs/operators';
import * as i1 from '@progress/kendo-angular-popup';
import { PopupService, POPUP_CONTAINER, PopupModule } from '@progress/kendo-angular-popup';
import * as i4$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i3 from '@progress/kendo-angular-intl';

const getTouch = (domEvent) => {
    return {
        x: {
            location: domEvent.pageX
        },
        y: {
            location: domEvent.pageY
        }
    };
};
const eventArgs = (e, previousArgs) => {
    const pointers = e.pointers;
    const pointer = pointers[0];
    const xLocation = pointer.pageX;
    const yLocation = pointer.pageY;
    let distance = 0;
    if (pointers.length > 1) {
        const pointer1 = pointers[0];
        const pointer2 = pointers[1];
        distance = Math.sqrt(Math.pow(pointer1.pageX - pointer2.pageX, 2) + Math.pow(pointer1.pageY - pointer2.pageY, 2));
    }
    return {
        distance: distance,
        event: e.srcEvent,
        preventDefault: function () {
            e.preventDefault();
        },
        target: e.target,
        touches: pointers.map(getTouch),
        type: e.type,
        x: {
            delta: previousArgs ? xLocation - previousArgs.x.location : 0,
            initialDelta: e.deltaX,
            location: xLocation,
            startLocation: xLocation - e.deltaX
        },
        y: {
            delta: previousArgs ? yLocation - previousArgs.y.location : 0,
            initialDelta: e.deltaY,
            location: yLocation,
            startLocation: yLocation - e.deltaY
        }
    };
};
function shouldBindGroup(groupNames, events) {
    for (let idx = 0; idx < groupNames.length; idx++) {
        if (events[groupNames[idx]]) {
            return true;
        }
    }
    return false;
}
const eventGroups = [{
        end: 'panend',
        move: 'panmove',
        start: 'panstart'
    }, {
        gesturechange: 'pinchmove',
        gestureend: 'pinchend',
        gesturestart: 'pinchstart'
    }, {
        press: 'press'
    }, {
        tap: 'tap'
    }];
/**
 * @hidden
 */
class DomEvents {
    constructor(hammerInstance, events) {
        this.hammerInstance = hammerInstance;
        this.eventHandlers = {};
        this.tap = this.tap.bind(this);
        this.press = this.press.bind(this);
        this.panstart = this.panstart.bind(this);
        this.panmove = this.panmove.bind(this);
        this.panend = this.panend.bind(this);
        this.pinchstart = this.pinchstart.bind(this);
        this.pinchmove = this.pinchmove.bind(this);
        this.pinchend = this.pinchend.bind(this);
        if (events) {
            this.bind(events);
        }
    }
    tap(e) {
        this.trigger('tap', e);
    }
    press(e) {
        this.trigger('press', e);
    }
    panstart(e) {
        delete this.previous;
        this.previous = this.trigger('start', e);
    }
    panmove(e) {
        this.previous = this.trigger('move', e);
    }
    panend(e) {
        this.trigger('end', e);
        delete this.previous;
    }
    pinchstart(e) {
        this.trigger('gesturestart', e);
    }
    pinchmove(e) {
        this.trigger('gesturechange', e);
    }
    pinchend(e) {
        this.trigger('gestureend', e);
    }
    trigger(name, e) {
        const args = eventArgs(e, this.previous);
        if (this.eventHandlers[name]) {
            this.eventHandlers[name](args);
        }
        return args;
    }
    bind(events = {}) {
        this.unbind();
        this.eventHandlers = events;
        for (let idx = 0; idx < eventGroups.length; idx++) {
            const eventGroup = eventGroups[idx];
            const groupNames = Object.keys(eventGroup);
            if (shouldBindGroup(groupNames, events)) {
                for (let nameIdx = 0; nameIdx < groupNames.length; nameIdx++) {
                    const name = eventGroup[groupNames[nameIdx]];
                    this.hammerInstance.on(name, this[name]);
                }
            }
        }
    }
    unbind() {
        if (this.hammerInstance) {
            this.hammerInstance.off();
        }
        this.eventHandlers = {};
    }
    destroy() {
        if (this.hammerInstance) {
            this.hammerInstance.destroy();
            delete this.hammerInstance;
        }
        delete this.eventHandlers;
    }
    toggleDrag(enable) {
        this.toggle('pan', enable);
    }
    toggleZoom(enable) {
        this.toggle('pinch', enable);
    }
    toggle(recognizer, enable) {
        if (this.hammerInstance) {
            const instanceRecognizer = this.hammerInstance.get(recognizer);
            instanceRecognizer.set({
                enable: enable
            });
        }
    }
}

const MISSING_HAMMER_MESSAGE = 'Hammerjs is not loaded.' +
    'Solution: http://www.telerik.com/kendo-angular-ui/components/charts/troubleshooting/#toc-hammerjs-is-not-loaded';
/**
 * @hidden
 */
class DomEventsBuilder {
    static create(element, events) {
        if (typeof window !== 'undefined') {
            const HAMMER = window.Hammer;
            if (!HAMMER) {
                if (isDevMode()) {
                    throw new Error(MISSING_HAMMER_MESSAGE);
                }
                return;
            }
            const hammerInstance = new HAMMER(element, {
                recognizers: [
                    [HAMMER.Tap],
                    [HAMMER.Pan],
                    [HAMMER.Pinch],
                    [HAMMER.Press, { time: 0 }]
                ]
            });
            return new DomEvents(hammerInstance, events);
        }
    }
}

const dateCategoryAxisFormats = DateCategoryAxis.prototype.options.labels.dateFormats;
const dateValueAxisFormats = DateValueAxis.prototype.options.labels.dateFormats;
const dateFormats = {
    milliseconds: "HH:mm:ss.SSS",
    seconds: { time: 'medium' },
    minutes: { time: 'short' },
    hours: { time: 'short' },
    days: { skeleton: 'Md' },
    weeks: { skeleton: 'Md' },
    months: { skeleton: 'yyMMM' },
    years: { skeleton: 'y' }
};
Object.assign(dateCategoryAxisFormats, dateFormats);
Object.assign(dateValueAxisFormats, dateFormats);
DomEventsBuilder$1.register(DomEventsBuilder);

/**
 * A directive which selects a [template](link:site.data.urls.angular['templatesyntax'])
 * within the `<kendo-chart>` component for the
 * [Donut center template](slug:donut_seriestypes_charts#toc-using-the-center-template).
 */
class DonutCenterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DonutCenterTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DonutCenterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
DonutCenterTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: DonutCenterTemplateDirective, selector: "[kendoChartDonutCenterTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DonutCenterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChartDonutCenterTemplate]'
                }]
        }], ctorParameters: function () {
        return [{ type: i0.TemplateRef, decorators: [{
                        type: Optional
                    }] }];
    } });

/**
 * @hidden
 */
class ItemChange {
    constructor(sender, options) {
        this.sender = sender;
        this.options = options;
    }
}
/**
 * @hidden
 */
class CollectionService {
    constructor() {
        this.source = new Subject();
        this.onItemChange$ = this.source.asObservable();
    }
    notify(change) {
        this.source.next(change);
    }
}
CollectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CollectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

/**
 * @hidden
 */
function copyChanges(changes, options) {
    for (const propertyName in changes) {
        if (!Object.hasOwnProperty.call(changes, propertyName)) {
            continue;
        }
        const value = changes[propertyName].currentValue;
        if (value === undefined) {
            delete options[propertyName];
        }
        else {
            options[propertyName] = value;
        }
    }
}

/**
 * @hidden
 */
function toSimpleChanges(changes) {
    const result = {};
    for (const propertyName in changes) {
        if (!Object.hasOwnProperty.call(changes, propertyName)) {
            continue;
        }
        result[propertyName] = new SimpleChange(null, changes[propertyName], false);
    }
    return result;
}

/**
 * @hidden
 */
const THROTTLE_MS = 1000 / 60;
/**
 * @hidden
 */
class Change {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
/**
 * @hidden
 */
class ConfigurationService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.store = {};
        this.source = new BehaviorSubject({});
        this.initSource();
    }
    initSource() {
        this.onFastChange$ = this.source.asObservable();
        this.onChange$ = this.onFastChange$.pipe(auditTime(THROTTLE_MS));
    }
    push(store) {
        this.store = store;
        this.next();
    }
    notify(change) {
        this.set(change.key, change.value);
        this.next();
    }
    set(field, value) {
        let store = this.store;
        const parts = field.split('.');
        let key = parts.shift();
        while (parts.length > 0) {
            store = store[key] = store[key] || {};
            key = parts.shift();
        }
        store[key] = value;
    }
    next() {
        this.ngZone.runOutsideAngular(() => {
            this.source.next(this.store);
        });
    }
}
ConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ConfigurationService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
ConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ConfigurationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ConfigurationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

/**
 * @hidden
 */
class CollectionItemComponent {
    constructor(configurationService, collectionService) {
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.options = {};
        this.subscription = configurationService.onFastChange$.subscribe(store => {
            this.options = store;
            this.notify();
        });
    }
    ngOnChanges(changes) {
        const store = this.configurationService.store;
        copyChanges(changes, store);
        this.configurationService.push(store);
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * item.notifyChanges({ visible: true });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    notify() {
        if (!this.collectionService) {
            return;
        }
        this.collectionService.notify(new ItemChange(this, this.options));
    }
}
CollectionItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Directive });
CollectionItemComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: CollectionItemComponent, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionItemComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; } });

/**
 * @hidden
 */
class SettingsComponent {
    constructor(configKey, configurationService) {
        this.configKey = configKey;
        this.configurationService = configurationService;
        this.store = {};
        if (configKey === undefined) {
            throw new Error('Configuration key not set');
        }
    }
    ngOnDestroy() {
        this.store = undefined;
        this.notify();
    }
    ngOnChanges(changes) {
        copyChanges(changes, this.store);
        this.notify();
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * item.notifyChanges({ visible: true });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    markAsVisible() {
        this.store.visible = true;
        this.notify();
    }
    notify() {
        this.configurationService.notify(new Change(this.configKey, this.store));
    }
}
SettingsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SettingsComponent, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
SettingsComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: SettingsComponent, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SettingsComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }, { type: ConfigurationService }]; } });

/**
 * The configuration options of the Chart series tooltip
 * ([see example]({% slug tooltips_chart_charts %})).
 */
class SeriesTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
    get seriesTooltipTemplateRef() {
        return this.seriesTooltipTemplate;
    }
}
SeriesTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesTooltipComponent, selector: "kendo-chart-series-item-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, queries: [{ propertyName: "seriesTooltipTemplate", first: true, predicate: TemplateRef, descendants: true }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }], seriesTooltipTemplate: [{
                type: ContentChild,
                args: [TemplateRef, { static: false }]
            }] } });

const toggle = (flag) => flag === undefined ? false : !flag;
/**
 * The configuration component for a series item.
 */
class SeriesItemComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
    /**
     * Toggles the series visibility and updates the parent Chart
     * without animated transitions.
     */
    toggleVisibility() {
        this.options.visible = toggle(this.options.visible);
        this.notify();
    }
    /**
     * Toggles the visibility of a point with the given index.
     * Applicable for the Pie, Donut, and Funnel series.
     *
     * @param pointIndex - The zero-based index of the point to toggle.
     */
    togglePointVisibility(pointIndex) {
        const pv = this.options.pointVisibility = this.options.pointVisibility || {};
        pv[pointIndex] = toggle(pv[pointIndex]);
        this.notify();
    }
    get seriesTooltipTemplateRef() {
        if (this.seriesTooltip) {
            return this.seriesTooltip.seriesTooltipTemplateRef;
        }
    }
}
SeriesItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
SeriesItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesItemComponent, selector: "kendo-chart-series-item", inputs: { aggregate: "aggregate", autoFit: "autoFit", axis: "axis", border: "border", categoryAxis: "categoryAxis", categoryField: "categoryField", closeField: "closeField", color: "color", colorField: "colorField", connectors: "connectors", currentField: "currentField", dashType: "dashType", data: "data", downColor: "downColor", downColorField: "downColorField", dynamicHeight: "dynamicHeight", dynamicSlope: "dynamicSlope", errorHighField: "errorHighField", errorLowField: "errorLowField", explodeField: "explodeField", field: "field", fromField: "fromField", gap: "gap", highField: "highField", holeSize: "holeSize", line: "line", lowField: "lowField", lowerField: "lowerField", margin: "margin", maxSize: "maxSize", mean: "mean", meanField: "meanField", median: "median", medianField: "medianField", minSize: "minSize", missingValues: "missingValues", name: "name", neckRatio: "neckRatio", negativeColor: "negativeColor", negativeValues: "negativeValues", noteTextField: "noteTextField", opacity: "opacity", openField: "openField", outliersField: "outliersField", overlay: "overlay", padding: "padding", q1Field: "q1Field", q3Field: "q3Field", segmentSpacing: "segmentSpacing", size: "size", sizeField: "sizeField", spacing: "spacing", stack: "stack", startAngle: "startAngle", style: "style", summaryField: "summaryField", target: "target", toField: "toField", type: "type", upperField: "upperField", visible: "visible", visibleInLegend: "visibleInLegend", visibleInLegendField: "visibleInLegendField", visual: "visual", width: "width", whiskers: "whiskers", xAxis: "xAxis", xErrorHighField: "xErrorHighField", xErrorLowField: "xErrorLowField", xField: "xField", yAxis: "yAxis", yErrorHighField: "yErrorHighField", yErrorLowField: "yErrorLowField", yField: "yField", zIndex: "zIndex", errorBars: "errorBars", extremes: "extremes", highlight: "highlight", labels: "labels", markers: "markers", notes: "notes", outliers: "outliers", tooltip: "tooltip" }, providers: [ConfigurationService], queries: [{ propertyName: "seriesTooltip", first: true, predicate: SeriesTooltipComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-series-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { aggregate: [{
                type: Input
            }], autoFit: [{
                type: Input
            }], axis: [{
                type: Input
            }], border: [{
                type: Input
            }], categoryAxis: [{
                type: Input
            }], categoryField: [{
                type: Input
            }], closeField: [{
                type: Input
            }], color: [{
                type: Input
            }], colorField: [{
                type: Input
            }], connectors: [{
                type: Input
            }], currentField: [{
                type: Input
            }], dashType: [{
                type: Input
            }], data: [{
                type: Input
            }], downColor: [{
                type: Input
            }], downColorField: [{
                type: Input
            }], dynamicHeight: [{
                type: Input
            }], dynamicSlope: [{
                type: Input
            }], errorHighField: [{
                type: Input
            }], errorLowField: [{
                type: Input
            }], explodeField: [{
                type: Input
            }], field: [{
                type: Input
            }], fromField: [{
                type: Input
            }], gap: [{
                type: Input
            }], highField: [{
                type: Input
            }], holeSize: [{
                type: Input
            }], line: [{
                type: Input
            }], lowField: [{
                type: Input
            }], lowerField: [{
                type: Input
            }], margin: [{
                type: Input
            }], maxSize: [{
                type: Input
            }], mean: [{
                type: Input
            }], meanField: [{
                type: Input
            }], median: [{
                type: Input
            }], medianField: [{
                type: Input
            }], minSize: [{
                type: Input
            }], missingValues: [{
                type: Input
            }], name: [{
                type: Input
            }], neckRatio: [{
                type: Input
            }], negativeColor: [{
                type: Input
            }], negativeValues: [{
                type: Input
            }], noteTextField: [{
                type: Input
            }], opacity: [{
                type: Input
            }], openField: [{
                type: Input
            }], outliersField: [{
                type: Input
            }], overlay: [{
                type: Input
            }], padding: [{
                type: Input
            }], q1Field: [{
                type: Input
            }], q3Field: [{
                type: Input
            }], segmentSpacing: [{
                type: Input
            }], size: [{
                type: Input
            }], sizeField: [{
                type: Input
            }], spacing: [{
                type: Input
            }], stack: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], style: [{
                type: Input
            }], summaryField: [{
                type: Input
            }], target: [{
                type: Input
            }], toField: [{
                type: Input
            }], type: [{
                type: Input
            }], upperField: [{
                type: Input
            }], visible: [{
                type: Input
            }], visibleInLegend: [{
                type: Input
            }], visibleInLegendField: [{
                type: Input
            }], visual: [{
                type: Input
            }], width: [{
                type: Input
            }], whiskers: [{
                type: Input
            }], xAxis: [{
                type: Input
            }], xErrorHighField: [{
                type: Input
            }], xErrorLowField: [{
                type: Input
            }], xField: [{
                type: Input
            }], yAxis: [{
                type: Input
            }], yErrorHighField: [{
                type: Input
            }], yErrorLowField: [{
                type: Input
            }], yField: [{
                type: Input
            }], zIndex: [{
                type: Input
            }], errorBars: [{
                type: Input
            }], extremes: [{
                type: Input
            }], highlight: [{
                type: Input
            }], labels: [{
                type: Input
            }], markers: [{
                type: Input
            }], notes: [{
                type: Input
            }], outliers: [{
                type: Input
            }], tooltip: [{
                type: Input
            }], seriesTooltip: [{
                type: ContentChild,
                args: [SeriesTooltipComponent, { static: false }]
            }] } });

const POSITION_MODE = 'absolute';
const COLLISION = { horizontal: "fit", vertical: "fit" };
/**
 * @hidden
 */
class BaseTooltip {
    constructor(popupService, localizationService) {
        this.popupService = popupService;
        this.localizationService = localizationService;
        this.style = {};
        this.popupRef = null;
    }
    get active() {
        return this.popupRef !== null;
    }
    show(e) {
        const align = e.anchor.align;
        const offset = this.position(e.anchor.point);
        this.style = e.style;
        if (!this.popupRef) {
            this.popupRef = this.popupService.open(Object.assign({
                offset: offset,
                popupAlign: align,
                animate: this.animate,
                content: this.templateRef,
                collision: COLLISION,
                positionMode: POSITION_MODE
            }, this.popupSettings));
            if (this.localizationService.rtl) {
                this.popupRef.popupElement.setAttribute('dir', 'rtl');
            }
            this.onInit();
        }
        else {
            const popup = this.popupRef.popup.instance;
            popup.offset = offset;
            popup.popupAlign = align;
        }
    }
    onInit() {
        /* noop */
    }
    hide() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    ngOnDestroy() {
        this.hide();
    }
    position(offset) {
        if (!this.popupSettings || !this.popupSettings.appendTo) {
            return offset;
        }
        const appendTo = this.popupSettings.appendTo.element.nativeElement;
        const bbox = appendTo.getBoundingClientRect();
        const { scrollLeft, scrollTop } = this.scrollOffset(appendTo);
        return {
            left: offset.left - bbox.left - scrollLeft,
            top: offset.top - bbox.top - scrollTop
        };
    }
    scrollOffset(element) {
        if (!element) {
            return null;
        }
        let scrollLeft = element.scrollLeft;
        let scrollTop = element.scrollTop;
        let parent = element.parentElement;
        while (parent) {
            scrollLeft += parent.scrollLeft;
            scrollTop += parent.scrollTop;
            parent = parent.parentElement;
        }
        return { scrollLeft, scrollTop };
    }
}
BaseTooltip.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: BaseTooltip, deps: [{ token: i1.PopupService }, { token: i4.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
BaseTooltip.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: BaseTooltip, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: BaseTooltip, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.PopupService }, { type: i4.LocalizationService }]; } });

/**
 * @hidden
 */
function bodyFactory() {
    if (isDocumentAvailable()) {
        return new ElementRef(document.body);
    }
}

/**
 * @hidden
 */
class CrosshairTooltipComponent extends BaseTooltip {
    constructor(popupService, localizationService) {
        super(popupService, localizationService);
        this.animate = false;
    }
    show(e) {
        super.show(e);
        this.value = e.value;
        this.popupRef.popup.changeDetectorRef.detectChanges();
    }
}
CrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CrosshairTooltipComponent, deps: [{ token: i1.PopupService }, { token: i4.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
CrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CrosshairTooltipComponent, selector: "kendo-chart-crosshair-tooltip", inputs: { key: "key", popupSettings: "popupSettings" }, providers: [PopupService, {
            provide: POPUP_CONTAINER,
            useFactory: bodyFactory
        }], viewQueries: [{ propertyName: "templateRef", first: true, predicate: ["content"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <div class="k-chart-tooltip k-chart-crosshair-tooltip" [ngStyle]="style">
                {{ value }}
            </div>
        </ng-template>
    `, isInline: true, directives: [{ type: i4$1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [PopupService, {
                            provide: POPUP_CONTAINER,
                            useFactory: bodyFactory
                        }],
                    selector: 'kendo-chart-crosshair-tooltip',
                    template: `
        <ng-template #content>
            <div class="k-chart-tooltip k-chart-crosshair-tooltip" [ngStyle]="style">
                {{ value }}
            </div>
        </ng-template>
    `
                }]
        }], ctorParameters: function () { return [{ type: i1.PopupService }, { type: i4.LocalizationService }]; }, propDecorators: { templateRef: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }], key: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }] } });

const AXES = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
/**
 * @hidden
 */
class CrosshairTooltipsContainerComponent {
    constructor() {
        this.tooltipKeys = [];
        this.tooltipsMap = {};
    }
    show(e) {
        const tooltipComponents = this.crossahirTooltipComponents.toArray();
        const axisName = e.axisName;
        const axisIndex = e.axisIndex;
        for (let idx = 0; idx < tooltipComponents.length; idx++) {
            if (tooltipComponents[idx].key === axisName + axisIndex) {
                tooltipComponents[idx].show(e);
                break;
            }
        }
    }
    hide() {
        const tooltipComponents = this.crossahirTooltipComponents.toArray();
        for (let idx = 0; idx < tooltipComponents.length; idx++) {
            tooltipComponents[idx].hide();
        }
    }
    get active() {
        return this.tooltipKeys.length > 0;
    }
    createCrosshairTooltips(options) {
        const newMap = this.mapTooltips(options);
        const map = this.tooltipsMap;
        for (const key in map) {
            if (!newMap[key]) {
                this.removeTooltip(key);
                delete map[key];
            }
        }
        for (const key in newMap) {
            if (!map[key]) {
                map[key] = newMap[key];
                this.tooltipKeys.push(key);
            }
        }
    }
    removeTooltip(key) {
        const keys = this.tooltipKeys;
        for (let idx = 0; idx < keys.length; idx++) {
            if (keys[idx] === key) {
                keys.splice(idx, 1);
                break;
            }
        }
    }
    mapTooltips(options) {
        const map = {};
        for (let idx = 0; idx < AXES.length; idx++) {
            const tooltips = this.axesCrosshairTooltipOptions(options, AXES[idx]);
            for (let tooltipIdx = 0; tooltipIdx < tooltips.length; tooltipIdx++) {
                const tooltip = tooltips[tooltipIdx];
                map[tooltip.name + tooltip.index] = tooltip;
            }
        }
        return map;
    }
    axesCrosshairTooltipOptions(options, name) {
        const result = [];
        if (options[name]) {
            const axes = [].concat(options[name]);
            for (let idx = 0; idx < axes.length; idx++) {
                const tooltip = (axes[idx].crosshair || {}).tooltip;
                if (tooltip && tooltip.visible) {
                    result.push({
                        index: idx,
                        name: name
                    });
                }
            }
        }
        return result;
    }
}
CrosshairTooltipsContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CrosshairTooltipsContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CrosshairTooltipsContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CrosshairTooltipsContainerComponent, selector: "kendo-chart-crosshair-tooltips-container", inputs: { popupSettings: "popupSettings" }, viewQueries: [{ propertyName: "crossahirTooltipComponents", predicate: CrosshairTooltipComponent, descendants: true }], ngImport: i0, template: `
        <kendo-chart-crosshair-tooltip *ngFor="let key of tooltipKeys" [key]="key" [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltip>
    `, isInline: true, components: [{ type: CrosshairTooltipComponent, selector: "kendo-chart-crosshair-tooltip", inputs: ["key", "popupSettings"] }], directives: [{ type: i4$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CrosshairTooltipsContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chart-crosshair-tooltips-container',
                    template: `
        <kendo-chart-crosshair-tooltip *ngFor="let key of tooltipKeys" [key]="key" [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltip>
    `
                }]
        }], propDecorators: { popupSettings: [{
                type: Input
            }], crossahirTooltipComponents: [{
                type: ViewChildren,
                args: [CrosshairTooltipComponent]
            }] } });

/**
 * A directive that selects a [template](link:site.data.urls.angular['templatesyntax'])
 * within the `<kendo-chart-tooltip>` component for the
 * [series tooltip](slug:tooltips_chart_charts#toc-specifying-a-template).
 * The following context fields are frequently utilized:
 * - `let-category="category"`&mdash;The category name.
 * - `let-dataItem="dataItem"`&mdash;The original data item used to construct the point. It will be `null` if binding to an array.
 * - `let-series="series"`&mdash;The data series.
 * - `let-value="value"`&mdash;The value of the point (either a number or an object).
 * For the full list of available fields, refer to the [`TooltipTemplatePoint`](slug:api_charts_tooltiptemplatepoint).
 *
  * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-tooltip>
 *          <ng-template kendoChartSeriesTooltipTemplate let-value="value">
 *             Value is {{value}}
 *           </ng-template>
 *       </kendo-chart-tooltip>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
class SeriesTooltipTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
SeriesTooltipTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesTooltipTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
SeriesTooltipTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: SeriesTooltipTemplateDirective, selector: "[kendoChartSeriesTooltipTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesTooltipTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChartSeriesTooltipTemplate]'
                }]
        }], ctorParameters: function () {
        return [{ type: i0.TemplateRef, decorators: [{
                        type: Optional
                    }] }];
    } });

/**
 * A directive that selects a [template](link:site.data.urls.angular['templatesyntax'])
 * within the `<kendo-chart-tooltip>` component for the
 * [shared series tooltip](slug:tooltips_chart_charts#toc-shared-tooltip-customization).
 * The available fields in the template context are:
 * - `let-points="points"`&mdash;An array of the [`TooltipTemplatePoints`](slug:api_charts_tooltiptemplatepoint) category.
 * - `let-category="category"`&mdash;The category name.
 * - `let-categoryText="categoryText"`&mdash;The category name as text.
 * - `let-nameColumn="nameColumn"`&mdash;Returns a Boolean [`value`](slug:api_charts_seriesitemcomponent#toc-name) indicating whether the name property of the `SeriesItemComponent` is defined.
 * - `let-colorMarker="colorMarker"`&mdash;Returns a Boolean value indicating whether one or more series colors are specified in the Chart. If the Chart contains only one `SeriesItemComponent`, the context field will return `false`.
 * - `let-colSpan="colSpan"`&mdash;Specifies the number of columns covered by the tooltip. The default value is `1` and increases by `1` if `nameColumn` and `colorMarker` are set to `true`.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-tooltip [shared]="true">
 *         <ng-template kendoChartSharedTooltipTemplate let-category="category" let-points="points">
 *             <div> {{ category }} </div>
 *             <div *ngFor="let point of points">
 *                 {{ point.series.name }} : {{ point.value }}
 *             </div>
 *         </ng-template>
 *       </kendo-chart-tooltip>
 *       <kendo-chart-category-axis>
 *         <kendo-chart-category-axis-item [categories]="['A', 'B', 'C']">
 *         </kendo-chart-category-axis-item>
 *       </kendo-chart-category-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item name="A" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item name="B" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
class SharedTooltipTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
SharedTooltipTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SharedTooltipTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
SharedTooltipTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: SharedTooltipTemplateDirective, selector: "[kendoChartSharedTooltipTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SharedTooltipTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChartSharedTooltipTemplate]'
                }]
        }], ctorParameters: function () {
        return [{ type: i0.TemplateRef, decorators: [{
                        type: Optional
                    }] }];
    } });

/**
 * The point that is passed to the tooltip template.
 */
class TooltipTemplatePoint {
    /**
     * @hidden
     */
    constructor(point, format, template) {
        this.value = point.value;
        this.category = point.category;
        this.categoryIndex = point.categoryIx;
        this.series = point.series;
        this.dataItem = point.dataItem;
        this.percentage = point.percentage;
        this.runningTotal = point.runningTotal;
        this.total = point.total;
        this.low = point.low;
        this.high = point.high;
        this.xLow = point.xLow;
        this.xHigh = point.xHigh;
        this.yLow = point.yLow;
        this.yHigh = point.yHigh;
        this.template = template;
        this.point = point;
        this.format = format;
    }
    /**
     * @hidden
     */
    get formattedValue() {
        return this.format ? this.point.formatValue(this.format) : String(this.value);
    }
}

/**
 * @hidden
 */
function hasParent(element, parent) {
    let current = element;
    while (current && current !== parent) {
        current = current.parentNode;
    }
    return current ? true : false;
}

/**
 * @hidden
 */
class TooltipTemplateService {
    setTemplate(template) {
        this.template = template;
    }
    getTemplate(seriesIndex) {
        if (this.seriesTemplates && this.seriesTemplates[seriesIndex]) {
            return this.seriesTemplates[seriesIndex];
        }
        return this.template;
    }
    setSeriesTemplates(seriesTemplates) {
        this.seriesTemplates = seriesTemplates;
    }
    setSharedTemplate(sharedTemplate) {
        this.sharedTemplate = sharedTemplate;
    }
    getSharedTemplate() {
        return this.sharedTemplate;
    }
}
TooltipTemplateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipTemplateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TooltipTemplateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipTemplateService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipTemplateService, decorators: [{
            type: Injectable
        }] });

const SHARED_TOOLTIP_CLASS = 'k-chart-shared-tooltip';
const TOOLTIP_CLASS = "k-chart-tooltip";
/**
 * @hidden
 */
class TooltipPopupComponent extends BaseTooltip {
    constructor(popupService, templateService, localizationService, ngZone) {
        super(popupService, localizationService);
        this.popupService = popupService;
        this.templateService = templateService;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.seriesTooltipContext = {};
        this.seriesSharedTooltipContext = {};
        this.animate = true;
        this.wrapperClass = 'k-chart-tooltip-wrapper';
        this.leave = new EventEmitter();
        this.popupClasses = {};
    }
    show(e) {
        this.shared = e.shared;
        this.popupClasses = Object.assign({
            [SHARED_TOOLTIP_CLASS]: e.shared,
            [TOOLTIP_CLASS]: true,
            [e.className]: !!e.className
        }, this.classNames);
        if (!e.shared) {
            this.seriesTooltipContext = new TooltipTemplatePoint(e.point, e.format);
            this.seriesTooltipTemplateRef = this.pointTemplateRef(e.point);
        }
        else {
            this.seriesSharedTooltipTemplateRef = this.templateService.getSharedTemplate()
                || this.defaultSharedTooltipTemplate.templateRef;
            this.seriesSharedTooltipContext = this.sharedTemplateContext(e);
        }
        super.show(e);
    }
    containsElement(element) {
        if (this.popupRef) {
            return hasParent(element, this.popupRef.popupElement);
        }
    }
    sharedTemplateContext(e) {
        const points = e.points;
        const nameColumn = points.filter((point) => typeof point.series.name !== 'undefined').length > 0;
        const colorMarker = e.series.length > 1;
        let colspan = 1;
        if (nameColumn) {
            colspan++;
        }
        if (colorMarker) {
            colspan++;
        }
        return {
            category: e.category,
            categoryText: e.categoryText,
            colorMarker: colorMarker,
            colspan: colspan,
            nameColumn: nameColumn,
            points: this.wrapPoints(e.points, e.format)
        };
    }
    pointTemplateRef(point) {
        return this.templateService.getTemplate(point.series.index) || this.defaultSeriesTooltipTemplate.templateRef;
    }
    wrapPoints(points, format) {
        const result = [];
        for (let idx = 0; idx < points.length; idx++) {
            const point = points[idx];
            const template = this.pointTemplateRef(point);
            const pointFormat = ((point.options || {}).tooltip || {}).format || format;
            result.push(new TooltipTemplatePoint(point, pointFormat, template));
        }
        return result;
    }
    onInit() {
        this.ngZone.runOutsideAngular(() => {
            this.mouseleaveSubscription = this.popupRef.popupElement.addEventListener('mouseleave', (args) => {
                this.leave.emit(args);
            });
        });
        this.popupRef.popupElement.className += ` ${this.wrapperClass}`;
    }
    hide() {
        if (this.mouseleaveSubscription) {
            this.mouseleaveSubscription();
            this.mouseleaveSubscription = null;
        }
        super.hide();
    }
}
TooltipPopupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipPopupComponent, deps: [{ token: i1.PopupService }, { token: TooltipTemplateService }, { token: i4.LocalizationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
TooltipPopupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: TooltipPopupComponent, selector: "kendo-chart-tooltip-popup", inputs: { animate: "animate", classNames: "classNames", popupSettings: "popupSettings", wrapperClass: "wrapperClass" }, outputs: { leave: "leave" }, providers: [PopupService, {
            provide: POPUP_CONTAINER,
            useFactory: bodyFactory
        }], viewQueries: [{ propertyName: "defaultSeriesTooltipTemplate", first: true, predicate: SeriesTooltipTemplateDirective, descendants: true }, { propertyName: "defaultSharedTooltipTemplate", first: true, predicate: SharedTooltipTemplateDirective, descendants: true }, { propertyName: "templateRef", first: true, predicate: ["content"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
    <ng-template #content>
        <div [ngClass]="popupClasses" [ngStyle]="style">
          <ng-template [ngTemplateOutlet]="seriesTooltipTemplateRef" *ngIf="!shared"
                    [ngTemplateOutletContext]="seriesTooltipContext">
          </ng-template>
          <ng-template [ngTemplateOutlet]="seriesSharedTooltipTemplateRef" *ngIf="shared"
                    [ngTemplateOutletContext]="seriesSharedTooltipContext">
          </ng-template>
        </div>
    </ng-template>

    <ng-template kendoChartSeriesTooltipTemplate let-formattedValue="formattedValue">
        <span [innerHTML]="formattedValue"></span>
    </ng-template>
    <ng-template kendoChartSharedTooltipTemplate let-points="points" let-categoryText="categoryText" let-colspan="colspan" let-colorMarker="colorMarker" let-nameColumn="nameColumn" >
        <table>
            <tr><th [attr.colspan]='colspan'> {{ categoryText }} </th></tr>
            <tr *ngFor="let point of points">
                <td *ngIf="colorMarker"><span class='k-chart-shared-tooltip-marker' [style.background-color]='point.series.color'></span></td>
                <td *ngIf="nameColumn">
                    <ng-container *ngIf="point.series.name !== undefined">{{ point.series.name }}</ng-container>
                    <ng-container *ngIf="point.series.name === undefined">&nbsp;</ng-container>
                </td>
                <td>
                  <ng-template [ngTemplateOutlet]="point.template"
                            [ngTemplateOutletContext]="point">
                  </ng-template>
                </td>
            </tr>
        </table>
    </ng-template>
    `, isInline: true, directives: [{ type: i4$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i4$1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i4$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: SeriesTooltipTemplateDirective, selector: "[kendoChartSeriesTooltipTemplate]" }, { type: SharedTooltipTemplateDirective, selector: "[kendoChartSharedTooltipTemplate]" }, { type: i4$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipPopupComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [PopupService, {
                            provide: POPUP_CONTAINER,
                            useFactory: bodyFactory
                        }],
                    selector: 'kendo-chart-tooltip-popup',
                    template: `
    <ng-template #content>
        <div [ngClass]="popupClasses" [ngStyle]="style">
          <ng-template [ngTemplateOutlet]="seriesTooltipTemplateRef" *ngIf="!shared"
                    [ngTemplateOutletContext]="seriesTooltipContext">
          </ng-template>
          <ng-template [ngTemplateOutlet]="seriesSharedTooltipTemplateRef" *ngIf="shared"
                    [ngTemplateOutletContext]="seriesSharedTooltipContext">
          </ng-template>
        </div>
    </ng-template>

    <ng-template kendoChartSeriesTooltipTemplate let-formattedValue="formattedValue">
        <span [innerHTML]="formattedValue"></span>
    </ng-template>
    <ng-template kendoChartSharedTooltipTemplate let-points="points" let-categoryText="categoryText" let-colspan="colspan" let-colorMarker="colorMarker" let-nameColumn="nameColumn" >
        <table>
            <tr><th [attr.colspan]='colspan'> {{ categoryText }} </th></tr>
            <tr *ngFor="let point of points">
                <td *ngIf="colorMarker"><span class='k-chart-shared-tooltip-marker' [style.background-color]='point.series.color'></span></td>
                <td *ngIf="nameColumn">
                    <ng-container *ngIf="point.series.name !== undefined">{{ point.series.name }}</ng-container>
                    <ng-container *ngIf="point.series.name === undefined">&nbsp;</ng-container>
                </td>
                <td>
                  <ng-template [ngTemplateOutlet]="point.template"
                            [ngTemplateOutletContext]="point">
                  </ng-template>
                </td>
            </tr>
        </table>
    </ng-template>
    `
                }]
        }], ctorParameters: function () { return [{ type: i1.PopupService }, { type: TooltipTemplateService }, { type: i4.LocalizationService }, { type: i0.NgZone }]; }, propDecorators: { defaultSeriesTooltipTemplate: [{
                type: ViewChild,
                args: [SeriesTooltipTemplateDirective, { static: false }]
            }], defaultSharedTooltipTemplate: [{
                type: ViewChild,
                args: [SharedTooltipTemplateDirective, { static: false }]
            }], templateRef: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }], animate: [{
                type: Input
            }], classNames: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], wrapperClass: [{
                type: Input
            }], leave: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class ChartInstanceObserver extends InstanceObserver {
    constructor(instance) {
        super(instance);
        this.handlerMap = {
            hideTooltip: 'onHideTooltip',
            legendItemClick: 'onLegendItemClick',
            render: 'onRender',
            showTooltip: 'onShowTooltip',
            init: 'onInit'
        };
    }
}

/**
 * @hidden
 */
class BaseEvent {
    /**
     * @hidden
     */
    constructor(sender) {
        this.sender = sender;
    }
}
BaseEvent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: BaseEvent, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
BaseEvent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: BaseEvent, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: BaseEvent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; } });

/**
 * Arguments for the `axisLabelClick` event.
 */
class AxisLabelClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.dataItem = e.dataItem;
        this.index = e.index;
        this.text = e.text;
        this.value = e.value;
    }
}

/**
 * @hidden
 */
class PreventableEvent extends BaseEvent {
    constructor() {
        super(...arguments);
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}
PreventableEvent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PreventableEvent, deps: null, target: i0.ɵɵFactoryTarget.Directive });
PreventableEvent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: PreventableEvent, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PreventableEvent, decorators: [{
            type: Directive
        }] });

/**
 * Arguments for the `drag` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class DragEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `dragEnd` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class DragEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `dragStart` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class DragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * @hidden
 */
class LegendEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.series = e.series;
        this.seriesIndex = e.seriesIndex;
        this.pointIndex = e.pointIndex;
        this.text = e.text;
    }
}

/**
 * Arguments for the `legendItemHover` event.
 */
class LegendItemHoverEvent extends LegendEvent {
    /**
     * If called, the series highlight is not shown as a result of hovering over the legend item.
     */
    preventDefault() {
        super.preventDefault();
    }
}

/* eslint-disable no-empty */
/**
 * Arguments for the `legendItemLeave` event.
 */
class LegendItemLeaveEvent extends LegendEvent {
    /**
     * @hidden
     */
    preventDefault() {
        /* noop */
    }
    /**
     * @hidden
     */
    isDefaultPrevented() {
        return false;
    }
}

/**
 * @hidden
 */
class NoteEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.series = e.series;
        this.value = e.value;
        this.visual = e.visual;
    }
}

/**
 * Arguments for the `noteClick` event.
 */
class NoteClickEvent extends NoteEvent {
}

/**
 * Arguments for the `noteHover` event.
 */
class NoteHoverEvent extends NoteEvent {
}

/**
 * Arguments for the `noteLeave` event.
 */
class NoteLeaveEvent extends NoteEvent {
}

/**
 * Arguments for the `paneRender` event.
 */
class PaneRenderEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(args, sender) {
        super(sender);
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `plotAreaClick` event.
 */
class PlotAreaClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.originalEvent = e.originalEvent;
        this.value = e.value;
        this.x = e.x;
        this.y = e.y;
    }
}

/**
 * Arguments for the `plotAreaHover` event.
 */
class PlotAreaHoverEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.originalEvent = e.originalEvent;
        this.value = e.value;
        this.x = e.x;
        this.y = e.y;
    }
}

class PlotAreaLeaveEvent extends BaseEvent {
}

/**
 * Arguments for the `render` event.
 */
class RenderEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(_e, sender) {
        super(sender);
    }
}

/**
 * Arguments for the `select` event.
 */
class SelectEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `selectEnd` event.
 */
class SelectEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `selectStart` event.
 */
class SelectStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `seriesClick` event.
 */
class SeriesClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.originalEvent = e.originalEvent;
        this.percentage = e.percentage;
        this.point = e.point;
        this.series = e.series;
        this.stackValue = e.stackValue;
        this.value = e.value;
    }
}

/**
 * @hidden
 */
class SeriesEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.originalEvent = e.originalEvent;
        this.percentage = e.percentage;
        this.point = e.point;
        this.series = e.series;
        this.stackValue = e.stackValue;
        this.value = e.value;
    }
}

/**
 * Arguments for the `seriesHover` event.
 */
class SeriesHoverEvent extends SeriesEvent {
}

/**
 * Arguments for the `seriesOver` event.
 */
class SeriesOverEvent extends SeriesEvent {
}

/**
 * Arguments for the `seriesLeave` event.
 */
class SeriesLeaveEvent extends SeriesEvent {
}

/**
 * Arguments for the `zoom` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class ZoomEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.delta = e.delta;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `zoomEnd` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class ZoomEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `zoomStart` event ([see example](slug:panzoom_chart_charts#toc-pan-and-zoom-events)).
 */
class ZoomStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

const EVENT_MAP$1 = {
    axisLabelClick: AxisLabelClickEvent,
    drag: DragEvent,
    dragEnd: DragEndEvent,
    dragStart: DragStartEvent,
    legendItemHover: LegendItemHoverEvent,
    legendItemLeave: LegendItemLeaveEvent,
    noteClick: NoteClickEvent,
    noteHover: NoteHoverEvent,
    noteLeave: NoteLeaveEvent,
    paneRender: PaneRenderEvent,
    plotAreaClick: PlotAreaClickEvent,
    plotAreaHover: PlotAreaHoverEvent,
    plotAreaLeave: PlotAreaLeaveEvent,
    render: RenderEvent,
    select: SelectEvent,
    selectEnd: SelectEndEvent,
    selectStart: SelectStartEvent,
    seriesClick: SeriesClickEvent,
    seriesHover: SeriesHoverEvent,
    seriesOver: SeriesOverEvent,
    seriesLeave: SeriesLeaveEvent,
    zoom: ZoomEvent,
    zoomEnd: ZoomEndEvent,
    zoomStart: ZoomStartEvent
};
/**
 * @hidden
 */
class InstanceEventService {
    create(name, args, sender) {
        if (EVENT_MAP$1[name]) {
            return new EVENT_MAP$1[name](args, sender);
        }
    }
}

/**
 * Arguments for the `legendItemClick` event.
 */
class LegendItemClickEvent extends LegendEvent {
    /**
     * If called, the series visibility is not toggled as a result of clicking the legend item.
     */
    preventDefault() {
        super.preventDefault();
    }
}

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-charts',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1684310589,
    version: '12.1.0',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * Fallback theme in case the Theme Service fails
 * to read the variables from the main theme.
 *
 * @hidden
 */
const chartDefaultTheme = () => Object.assign({}, chartBaseTheme(), {
    axisDefaults: {
        crosshair: {
            color: 'rgba(0, 0, 0, 0.5)'
        },
        labels: {
            color: 'rgb(101, 101, 101)',
            font: '12px serif'
        },
        line: {
            color: 'rgba(0, 0, 0, 0.08)'
        },
        majorGridLines: {
            color: 'rgba(0, 0, 0, 0.08)'
        },
        minorGridLines: {
            color: 'rgba(0, 0, 0, 0.04)'
        },
        notes: {
            icon: {
                background: 'rgba(0, 0, 0, 0.5)',
                border: {
                    color: 'rgba(0, 0, 0, 0.5)'
                }
            },
            line: {
                color: 'rgba(0, 0, 0, 0.5)'
            },
            label: {
                font: '14px serif'
            }
        },
        title: {
            color: 'rgb(101, 101, 101)',
            font: '14px serif'
        }
    },
    chartArea: {
        background: 'rgb(255, 255, 255)'
    },
    legend: {
        inactiveItems: {
            labels: {
                color: 'rgba(102, 102, 102, 0.5)'
            },
            markers: {
                color: 'rgba(102, 102, 102, 0.5)'
            }
        },
        labels: {
            color: 'rgb(101, 101, 101)',
            font: '14px serif'
        }
    },
    seriesDefaults: {
        boxPlot: {
            downColor: 'rgba(0, 0, 0, 0.08)',
            mean: {
                color: 'rgb(246, 246, 246)'
            },
            median: {
                color: 'rgb(246, 246, 246)'
            },
            whiskers: {
                color: 'rgb(255, 99, 88)'
            }
        },
        bullet: {
            target: {
                color: 'rgb(101, 101, 101)'
            }
        },
        candlestick: {
            downColor: 'rgb(101, 101, 101)',
            line: {
                color: 'rgb(101, 101, 101)'
            }
        },
        errorBars: {
            color: 'rgba(0, 0, 0, 0.5)'
        },
        horizontalWaterfall: {
            line: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        icon: {
            border: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        labels: {
            background: 'rgb(255, 255, 255)',
            color: 'rgb(101, 101, 101)',
            opacity: 0.8,
            font: '12px serif'
        },
        notes: {
            icon: {
                background: 'rgba(0, 0, 0, 0.5)',
                border: {
                    color: 'rgba(0, 0, 0, 0.5)'
                }
            },
            line: {
                color: 'rgba(0, 0, 0, 0.5)'
            },
            label: {
                font: '14px serif'
            }
        },
        overlay: {
            gradient: "none"
        },
        verticalBoxPlot: {
            downColor: 'rgba(0, 0, 0, 0.08)',
            mean: {
                color: 'rgb(246, 246, 246)'
            },
            median: {
                color: 'rgb(246, 246, 246)'
            },
            whiskers: {
                color: 'rgb(255, 99, 88)'
            }
        },
        verticalBullet: {
            target: {
                color: 'rgb(101, 101, 101)'
            }
        },
        waterfall: {
            line: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        area: {
            opacity: 0.8
        }
    },
    title: {
        color: 'rgb(101, 101, 101)',
        font: '16px serif'
    },
    seriesColors: [
        'rgb(255, 99, 88)',
        'rgb(255, 210, 70)',
        'rgb(120, 210, 55)',
        'rgb(40, 180, 200)',
        'rgb(45, 115, 245)',
        'rgb(170, 70, 190)'
    ]
});

const font = (style) => `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
const computedBackgroundColor = (element) => window.getComputedStyle(element).backgroundColor;
const letterPos = (letter) => letter.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
const seriesPos = (name) => {
    const alpha = name.match(/series-([a-z])$/);
    if (alpha !== null) {
        return letterPos(alpha[1]);
    }
    const num = name.split('--series-')[1];
    return parseInt(num, 10) - 1;
};
const SERIES_COLORS = 30;
const seriesTemplate = () => {
    let template = `
      <div class="k-var--series-a"></div>
      <div class="k-var--series-b"></div>
      <div class="k-var--series-c"></div>
      <div class="k-var--series-d"></div>
      <div class="k-var--series-e"></div>
      <div class="k-var--series-f"></div>
  `;
    for (let i = 0; i < SERIES_COLORS; i++) {
        template += `
      <div class="k-var--series-${i + 1}"></div>`;
    }
    return template;
};
const template = () => `
    <div class="k-var--primary"></div>
    <div class="k-var--primary-contrast"></div>
    <div class="k-var--base"></div>
    <div class="k-var--background"></div>

    <div class="k-var--normal-background"></div>
    <div class="k-var--normal-text-color"></div>
    <div class="k-var--hover-background"></div>
    <div class="k-var--hover-text-color"></div>
    <div class="k-var--selected-background"></div>
    <div class="k-var--selected-text-color"></div>
    <div class="k-var--chart-error-bars-background"></div>
    <div class="k-var--chart-notes-background"></div>
    <div class="k-var--chart-notes-border"></div>
    <div class="k-var--chart-notes-lines"></div>
    <div class="k-var--chart-crosshair-background"></div>

    <div class="k-var--chart-inactive"></div>
    <div class="k-var--chart-major-lines"></div>
    <div class="k-var--chart-minor-lines"></div>
    <div class="k-var--chart-area-opacity"></div>
    <div class="k-var--chart-area-inactive-opacity"></div>
    <div class="k-var--chart-line-inactive-opacity"></div>

    <div class="k-widget k-chart">
        <div class="k-var--chart-font"></div>
        <div class="k-var--chart-title-font"></div>
        <div class="k-var--chart-pane-title-font"></div>
        <div class="k-var--chart-label-font"></div>
    </div>

    <div class="k-var--series-unset"></div>
    <div class="k-var--series">
      ${seriesTemplate()}
    </div>
`;
/**
 * @hidden
 */
class ThemeService extends ConfigurationService {
    constructor(ngZone) {
        super(ngZone);
        this.loaded = false;
    }
    loadTheme() {
        if (this.loaded || !isDocumentAvailable()) {
            return;
        }
        if (!this.readTheme()) {
            this.readDefaultTheme();
        }
        this.loaded = true;
        this.next();
    }
    readTheme() {
        this.createElement();
        const available = this.queryColor('primary') !==
            this.queryColor('primary-contrast');
        try {
            if (available) {
                this.push(chartBaseTheme());
                this.setColors();
                this.setFonts();
                this.setSeriesColors();
            }
        }
        finally {
            this.destroyElement();
        }
        return available;
    }
    readDefaultTheme() {
        this.push(chartDefaultTheme());
    }
    createElement() {
        const container = this.element = document.createElement('div');
        container.style.display = 'none';
        container.innerHTML = template();
        document.body.appendChild(container);
    }
    destroyElement() {
        if (this.element) {
            document.body.removeChild(this.element);
            this.element = undefined;
        }
    }
    setStyle(key, value) {
        this.set(key, value);
    }
    setColors() {
        this.mapColor('axisDefaults.crosshair.color', 'chart-crosshair-background');
        this.mapColor('axisDefaults.labels.color', 'normal-text-color');
        this.mapColor('axisDefaults.line.color', 'chart-major-lines');
        this.mapColor('axisDefaults.majorGridLines.color', 'chart-major-lines');
        this.mapColor('axisDefaults.minorGridLines.color', 'chart-minor-lines');
        this.mapColor('axisDefaults.notes.icon.background', 'chart-notes-background');
        this.mapColor('axisDefaults.notes.icon.border.color', 'chart-notes-border');
        this.mapColor('axisDefaults.notes.line.color', 'chart-notes-lines');
        this.mapColor('axisDefaults.title.color', 'normal-text-color');
        this.mapColor('chartArea.background', 'background');
        this.mapColor('legend.inactiveItems.labels.color', 'chart-inactive');
        this.mapColor('legend.inactiveItems.markers.color', 'chart-inactive');
        this.mapColor('legend.labels.color', 'normal-text-color');
        this.mapColor('seriesDefaults.boxPlot.downColor', 'chart-major-lines');
        this.mapColor('seriesDefaults.boxPlot.mean.color', 'base');
        this.mapColor('seriesDefaults.boxPlot.median.color', 'base');
        this.mapColor('seriesDefaults.boxPlot.whiskers.color', 'primary');
        this.mapColor('seriesDefaults.bullet.target.color', 'normal-text-color');
        this.mapColor('seriesDefaults.candlestick.downColor', 'normal-text-color');
        this.mapColor('seriesDefaults.candlestick.line.color', 'normal-text-color');
        this.mapColor('seriesDefaults.errorBars.color', 'chart-error-bars-background');
        this.mapColor('seriesDefaults.horizontalWaterfall.line.color', 'chart-major-lines');
        this.mapColor('seriesDefaults.icon.border.color', 'chart-major-lines');
        this.mapColor('seriesDefaults.labels.background', 'background');
        this.mapColor('seriesDefaults.labels.color', 'normal-text-color');
        this.mapColor('seriesDefaults.notes.icon.background', 'chart-notes-background');
        this.mapColor('seriesDefaults.notes.icon.border.color', 'chart-notes-border');
        this.mapColor('seriesDefaults.notes.line.color', 'chart-notes-lines');
        this.mapColor('seriesDefaults.verticalBoxPlot.downColor', 'chart-major-lines');
        this.mapColor('seriesDefaults.verticalBoxPlot.mean.color', 'base');
        this.mapColor('seriesDefaults.verticalBoxPlot.median.color', 'base');
        this.mapColor('seriesDefaults.verticalBoxPlot.whiskers.color', 'primary');
        this.mapColor('seriesDefaults.verticalBullet.target.color', 'normal-text-color');
        this.mapColor('seriesDefaults.waterfall.line.color', 'chart-major-lines');
        this.mapColor('title.color', 'normal-text-color');
        this.mapColor('subtitle.color', 'normal-text-color');
        const opacity = parseFloat(this.queryStyle('chart-area-opacity').opacity);
        if (!isNaN(opacity)) {
            this.setStyle('seriesDefaults.area.opacity', opacity);
            this.setStyle('seriesDefaults.radarArea.opacity', opacity);
            this.setStyle('seriesDefaults.verticalArea.opacity', opacity);
            this.setStyle('seriesDefaults.labels.opacity', opacity);
        }
        this.setInactiveOpacity(['area', 'verticalArea'], 'chart-area-inactive-opacity');
        this.setInactiveOpacity(['line', 'verticalLine'], 'chart-line-inactive-opacity');
    }
    setInactiveOpacity(seriesTypes, selector) {
        const inactiveOpacity = parseFloat(this.queryStyle(selector).opacity);
        if (!isNaN(inactiveOpacity) && inactiveOpacity < 1) {
            seriesTypes.forEach(type => this.setStyle(`seriesDefaults.${type}.highlight.inactiveOpacity`, inactiveOpacity));
        }
    }
    setFonts() {
        const defaultFont = font(this.queryStyle('chart-font'));
        const titleFont = font(this.queryStyle('chart-title-font'));
        const paneTitleFont = font(this.queryStyle('chart-pane-title-font'));
        const labelFont = font(this.queryStyle('chart-label-font'));
        this.setStyle('axisDefaults.labels.font', labelFont);
        this.setStyle('axisDefaults.notes.label.font', defaultFont);
        this.setStyle('axisDefaults.title.font', defaultFont);
        this.setStyle('legend.labels.font', defaultFont);
        this.setStyle('seriesDefaults.labels.font', labelFont);
        this.setStyle('seriesDefaults.notes.label.font', defaultFont);
        this.setStyle('title.font', titleFont);
        this.setStyle('subtitle.font', paneTitleFont);
        this.setStyle('paneDefaults.title.font', paneTitleFont);
    }
    setSeriesColors() {
        const element = this.element;
        const series = [].slice.call(element.querySelectorAll('.k-var--series div'));
        const unsetColor = computedBackgroundColor(element.querySelector('.k-var--series-unset'));
        const seriesColors = series.reduce((arr, el) => {
            const pos = seriesPos(el.className);
            const color = computedBackgroundColor(el);
            if (color !== unsetColor) {
                arr[pos] = color;
            }
            return arr;
        }, [] // Will populate the series colors in this array
        );
        this.setStyle('seriesColors', seriesColors);
    }
    mapColor(key, varName) {
        this.setStyle(key, this.queryColor(varName));
    }
    queryColor(varName) {
        return this.queryStyle(varName).backgroundColor;
    }
    queryStyle(varName) {
        const element = this.element.querySelector(`.k-var--${varName}`);
        return window.getComputedStyle(element);
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ThemeService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ThemeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

function hasObservers(emitter) {
    return emitter.observers.length > 0;
}
/**
 * The root Chart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <button kendoButton (click)="toggleLegend()">Toggle Legend</button>
 *     <button kendoButton (click)="toggleSeries()">Toggle Series</button>
 *     <kendo-chart>
 *       <kendo-chart-legend [visible]="legendVisible">
 *       </kendo-chart-legend>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item *ngIf="seriesVisible" name="Series #1"
 *                                   type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 *   public legendVisible: boolean = true;
 *   public seriesVisible: boolean = true;
 *
 *   public toggleSeries(): void {
 *     this.seriesVisible = !this.seriesVisible;
 *   }
 *
 *   public toggleLegend(): void {
 *     this.legendVisible = !this.legendVisible;
 *   }
 * }
 *
 * ```
 */
class ChartComponent {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * Fires when the user clicks an axis label ([see example](slug:events_chart)).
         */
        this.axisLabelClick = new EventEmitter();
        /**
         * Fires as long as the user is dragging the Chart with the mouse or through swipe gestures.
         */
        this.drag = new EventEmitter();
        /**
         * Fires when the user stops dragging the Chart.
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fires when the user starts dragging the Chart.
         */
        this.dragStart = new EventEmitter();
        /**
         * Fires when the user hovers over a legend item ([see example](slug:events_charts)).
         */
        this.legendItemHover = new EventEmitter();
        /**
         * Fires when the cursor leaves a legend item.
         */
        this.legendItemLeave = new EventEmitter();
        /**
         * Fires when the user clicks a note.
         */
        this.noteClick = new EventEmitter();
        /**
         * Fires when the user hovers over a note.
         */
        this.noteHover = new EventEmitter();
        /**
         * Fires when the cursor leaves a note.
         */
        this.noteLeave = new EventEmitter();
        /**
         * Fires when a pane is rendered because the Chart:
         * * Is rendered.
         * * Performs panning or zooming.
         * * Is exported with different options.
         * The event is used to render custom visuals in the panes.
         */
        this.paneRender = new EventEmitter();
        /**
         * Fires when the user clicks the plot area ([see example](slug:events_charts)).
         * The `click` event is triggered by the `tap` and `contextmenu` events.
         * To distinguish between the original events, inspect the `e.originalEvent.type` field.
         */
        this.plotAreaClick = new EventEmitter();
        /**
         * Fires when the user hovers the plot area ([see example](slug:events_charts)).
         */
        this.plotAreaHover = new EventEmitter();
        /**
         * Fires when the cursor leaves the plot area.
         */
        this.plotAreaLeave = new EventEmitter();
        /**
         * Fires when the Chart is ready to render on screen ([see example](slug:events_charts)).
         * For example, you can use it to remove loading indicators.
         * Any changes made to the options are ignored.
         */
        this.render = new EventEmitter();
        /**
         * Fires when the user modifies the selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the user completes the modification of the selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.selectEnd = new EventEmitter();
        /**
         * Fires when the user starts modifying the axis selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.selectStart = new EventEmitter();
        /**
         * Fires when the user clicks the Chart series.
         *
         * The `click` event will be triggered by the `tap` and `contextmenu` events ([see example](slug:events_charts)).
         * To distinguish between the original events, inspect the `e.originalEvent.type` field.
         */
        this.seriesClick = new EventEmitter();
        /**
         * Fires when the user hovers the Chart series ([see example](slug:events_charts)).
         */
        this.seriesHover = new EventEmitter();
        /**
         * Fires when the cursor enters a series.
         */
        this.seriesOver = new EventEmitter();
        /**
         * Fires when the cursor leaves a series.
         */
        this.seriesLeave = new EventEmitter();
        /**
         * Fires as long as the user is zooming the Chart by using the mousewheel operation.
         */
        this.zoom = new EventEmitter();
        /**
         * Fires when the user stops zooming the Chart.
         */
        this.zoomEnd = new EventEmitter();
        /**
         * Fires when the user uses the mousewheel to zoom the Chart.
         */
        this.zoomStart = new EventEmitter();
        /**
         * Fires when a legend item is clicked before the selected series visibility is toggled.
         * Can be prevented.
         */
        this.legendItemClick = new EventEmitter();
        /**
         * Limits the automatic resizing of the Chart. Sets the maximum number of times per second
         * that the component redraws its content when the size of its container changes.
         * Defaults to `10`. To disable the automatic resizing, set it to `0`.
         *
         * @example
         * ```ts
         * _@Component({
         *     selector: 'my-app',
         *     template: `
         *         <kendo-chart [resizeRateLimit]="2">
         * <!--                 ^^^^^^^^^^^^^^^^^^^^^^
         *       Will update the size of the Chart up to two times a second.
         *       Resize the example pane or window to try it out.
         * -->
         *          <kendo-chart-series>
         *            <kendo-chart-series-item [data]="seriesData">
         *           </kendo-chart-series-item>
         *         </kendo-chart-series>
         *       </kendo-chart>
         *   `
         * })
         * export class AppComponent {
         *    seriesData: number[] = [1, 2, 3, 5];
         * }
         * ```
         */
        this.resizeRateLimit = 10;
        this.theme = null;
        this.suppressTransitions = false;
        this.rtl = false;
        this.hostClasses = ['k-chart', 'k-widget'];
        validatePackage(packageMetadata);
        this.themeService.loadTheme();
        this.refreshWait();
    }
    ngOnInit() {
        if (this.element) {
            this.hostClasses.forEach(name => {
                this.renderer.addClass(this.element.nativeElement, name);
            });
            this.renderer.setStyle(this.element.nativeElement, 'position', 'relative');
        }
    }
    ngAfterViewInit() {
        if (this.canRender) {
            this.ngZone.runOutsideAngular(() => {
                const chartMouseleave = this.renderer.listen(this.surfaceElement.nativeElement, 'mouseleave', this.chartMouseleave.bind(this));
                this.domSubscriptions = () => {
                    chartMouseleave();
                };
            });
        }
        this.setDirection();
        this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
        this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)));
    }
    ngAfterViewChecked() {
        if (this.instance && this.autoResize) {
            this.ngZone.runOutsideAngular(() => {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.resize();
                }, 0);
            });
        }
    }
    ngOnChanges(changes) {
        const store = this.configurationService.store;
        copyChanges(changes, store);
        store.popupSettings = null;
        this.configurationService.push(store);
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * chart.notifyChanges({ title: { text: 'New Title' } });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    ngOnDestroy() {
        this.destroyed = true;
        if (this.optionsChange) {
            this.optionsChange.unsubscribe();
        }
        if (this.domSubscriptions) {
            this.domSubscriptions();
            this.domSubscriptions = null;
        }
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.resizeTimeout);
        clearTimeout(this.redrawTimeout);
    }
    createInstance(element, observer) {
        this.instance = new Chart(element, this.options, this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    /**
     * Exports the Chart as an image. The export operation is asynchronous and returns a promise.
     *
     * @param {ImageExportOptions} options - The parameters for the exported image.
     * @returns {Promise<string>} - A promise that will be resolved with a PNG image encoded as a Data URI.
     */
    exportImage(options = {}) {
        return exportImage(this.exportVisual(options), options);
    }
    /**
     * Exports the Chart as an SVG document. The export operation is asynchronous and returns a promise.
     *
     * @param options - The parameters for the exported file.
     * @returns - A promise that will be resolved with an SVG document that is encoded as a Data URI.
     */
    exportSVG(options = {}) {
        return exportSVG(this.exportVisual(options), options);
    }
    /**
     * Exports the Chart as a Drawing `Scene`.
     *
     * @param options - The parameters for the export operation.
     * @returns - The root Group of the scene.
     */
    exportVisual(options = {}) {
        return this.instance.exportVisual(options);
    }
    /**
     * Returns the axis with the specified name.
     *
     * @param {string} name - The axis name.
     * @returns {ChartAxis} - The axis with a corresponding name.
     */
    findAxisByName(name) {
        if (this.instance) {
            return this.instance.findAxisByName(name);
        }
    }
    /**
     * Returns the pane at the specified index.
     *
     * @param {number} index - The pane index.
     * @returns {ChartPane} - The pane at the specified index.
     */
    findPaneByIndex(index) {
        if (this.instance) {
            return this.instance.findPaneByIndex(index);
        }
    }
    /**
     * Returns the pane with the specified name.
     *
     * @param {string} name - The name of the pane.
     * @returns {ChartPane} - The pane with the provided name.
     */
    findPaneByName(name) {
        if (this.instance) {
            return this.instance.findPaneByName(name);
        }
    }
    /**
     * Returns the plot area of the Chart.
     * @returns {ChartPlotArea} - The plot area of the Chart.
     */
    getPlotArea() {
        if (this.instance) {
            return this.instance.plotArea();
        }
    }
    /**
     * Highlights the series points or the segments of a Pie, Donut, or Funnel charts.
     *
     * See [Series Highlight]({% slug serieshighlight_chart_charts %}) for more details.
     *
     * In the following example, the callback is evaluated for each data point.
     * If the function returns `true`, the point is highlighted.
     *
     * {% meta height:500 %}
     * {% embed_file elements/highlight/api/app.component.ts preview %}
     * {% embed_file shared/app.module.ts hidden %}
     * {% embed_file shared/main.ts hidden %}
     * {% endmeta %}
     *
     * @param show - A Boolean value that indicates whether the highlight is shown or hidden.
     * @param filter - A string that represents the series or category name, an object with the series and category name, or a function which will be called for each point. The function should return `true` for the points for which the highlight is toggled.
     */
    toggleHighlight(show, filter) {
        if (this.instance) {
            this.instance.toggleHighlight(show, filter);
        }
    }
    /**
     * Hides the tooltip of the Chart.
     */
    hideTooltip() {
        if (this.instance) {
            this.instance.hideTooltip();
        }
    }
    /**
     * Shows the Chart tooltip of a specific point or the shared tooltip of a specific category.
     *
     * @param filter - The category for a shared tooltip or a function which will be called for each point until the function returns `true`.
     */
    showTooltip(filter) {
        if (this.instance) {
            this.instance.showTooltip(filter);
        }
    }
    init() {
        if (!this.canRender) {
            return;
        }
        const element = this.surfaceElement.nativeElement;
        const instanceObserver = new ChartInstanceObserver(this);
        this.createInstance(element, instanceObserver);
    }
    /**
     * Detects the size of the container and redraws the Chart.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    resize() {
        if (this.instance) {
            this.instance.resize();
        }
    }
    /**
     * @hidden
     */
    onResize() {
        if (this.autoResize) {
            this.resize();
        }
    }
    onLegendItemClick(e) {
        this.run(() => {
            const args = new LegendItemClickEvent(e, this);
            this.legendItemClick.emit(args);
            if (!args.isDefaultPrevented()) {
                const series = this.seriesComponents.toArray()[e.series.index];
                if (!series) {
                    return;
                }
                if (e.pointIndex === undefined) {
                    series.toggleVisibility();
                }
                else {
                    series.togglePointVisibility(e.pointIndex);
                }
                this.suppressTransitions = true;
            }
        }, hasObservers(this.legendItemClick), this.seriesComponents.length > 0);
    }
    onInit(e) {
        this.instance = e.sender;
    }
    onRender(e) {
        const donutCenterStyle = this.getDonutCenterStyle();
        this.run(() => {
            const args = new RenderEvent(e, this);
            this.surface = e.sender.surface;
            this.render.emit(args);
            this.donutCenterStyle = donutCenterStyle;
        }, hasObservers(this.render), this.donutCenterStyle !== donutCenterStyle);
    }
    onShowTooltip(e) {
        this.run(() => {
            if (!e.crosshair) {
                this.tooltipInstance.show(e);
            }
            else {
                this.crossahirTooltips.show(e);
            }
        }, !e.crosshair, true);
    }
    onHideTooltip(e) {
        if (!e.crosshair) {
            if (this.tooltipInstance.active) {
                this.tooltipInstance.hide();
                this.detectChanges();
            }
        }
        else if (this.crossahirTooltips.active) {
            this.crossahirTooltips.hide();
            this.detectChanges();
        }
    }
    trigger(name, e) {
        if (name === 'resize') {
            return;
        }
        const emitter = this.activeEmitter(name);
        if (emitter) {
            const args = this.instanceEventService.create(name, e, this);
            this.run(() => {
                emitter.emit(args);
            });
            return args.isDefaultPrevented && args.isDefaultPrevented();
        }
    }
    requiresHandlers(names) {
        for (let idx = 0; idx < names.length; idx++) {
            if (this.activeEmitter(names[idx])) {
                return true;
            }
        }
        return false;
    }
    refresh() {
        clearTimeout(this.redrawTimeout);
        this.updateDirection();
        this.crossahirTooltips.createCrosshairTooltips(this.options);
        this.setChartAreaSize();
        if (!this.instance) {
            this.init();
            return;
        }
        const transitions = this.options.transitions;
        if (this.suppressTransitions) {
            this.options.transitions = false;
        }
        this.updateOptions();
        if (this.suppressTransitions) {
            this.options.transitions = transitions;
            this.suppressTransitions = false;
        }
    }
    setChartAreaSize() {
        if (!this.element) {
            return;
        }
        const element = this.element.nativeElement;
        const chartArea = this.options.chartArea || {};
        if (chartArea.width) {
            element.style.width = `${chartArea.width}px`;
        }
        if (chartArea.height) {
            element.style.height = `${chartArea.height}px`;
        }
    }
    updateOptions() {
        this.instance.setOptions(this.options);
    }
    /**
     * @hidden
     */
    tooltipMouseleave(e) {
        const relatedTarget = e.relatedTarget;
        const chartElement = this.element.nativeElement;
        if (this.instance && (!relatedTarget || !hasParent(relatedTarget, chartElement))) {
            this.instance.hideElements();
        }
    }
    /**
     * @hidden
     */
    chartMouseleave(e) {
        const relatedTarget = e.relatedTarget;
        const chartElement = this.element.nativeElement;
        if (this.instance && (!relatedTarget || !(this.tooltipInstance.containsElement(relatedTarget) || hasParent(relatedTarget, chartElement))) &&
            !this.instance.handlingTap) {
            this.instance.hideElements();
        }
    }
    get canRender() {
        return isDocumentAvailable() && Boolean(this.surfaceElement);
    }
    get autoResize() {
        return this.resizeRateLimit > 0;
    }
    activeEmitter(name) {
        const emitter = this[name];
        if (emitter && emitter.emit && hasObservers(emitter)) {
            return emitter;
        }
    }
    getDonutCenterStyle() {
        if (!this.instance || !this.options || !this.options.series) {
            return;
        }
        const firstSeries = this.options.series[0];
        const charts = this.instance._plotArea.charts;
        if (!firstSeries || firstSeries.type !== 'donut' || !charts || charts[0].points.length === 0) {
            return;
        }
        const firstPoint = charts[0].points[0];
        const center = firstPoint.box.center();
        const radius = firstPoint.sector.innerRadius;
        const top = center.y - radius;
        const left = center.x - radius;
        const size = radius * 2;
        return {
            height: size + 'px',
            left: left + 'px',
            top: top + 'px',
            width: size + 'px'
        };
    }
    refreshWait() {
        this.ngZone.runOutsideAngular(() => {
            this.optionsChange = combineLatest(this.configurationService.onChange$, this.themeService.onChange$).pipe(tap((result) => {
                this.options = result[0];
                this.theme = result[1];
            }), auditTime(THROTTLE_MS))
                .subscribe(() => {
                this.refresh();
            });
        });
    }
    run(callback, inZone = true, detectChanges) {
        if (inZone) {
            if (detectChanges) {
                this.changeDetector.markForCheck();
            }
            this.ngZone.run(callback);
        }
        else {
            callback();
            if (detectChanges) {
                this.detectChanges();
            }
        }
    }
    detectChanges() {
        if (!this.destroyed) {
            this.changeDetector.detectChanges();
        }
    }
    intlChange() {
        if (this.instance) {
            this.deferredRedraw();
        }
    }
    rtlChange() {
        if (this.instance && this.rtl !== this.isRTL) {
            this.deferredRedraw();
        }
    }
    deferredRedraw() {
        this.ngZone.runOutsideAngular(() => {
            clearTimeout(this.redrawTimeout);
            this.redrawTimeout = setTimeout(() => {
                this.updateDirection();
                this.instance.noTransitionsRedraw();
            }, 0);
        });
    }
    updateDirection() {
        const current = this.isRTL;
        if (this.rtl !== current) {
            this.setDirection();
            if (this.instance) {
                this.instance.setDirection(current);
            }
        }
    }
    setDirection() {
        this.rtl = this.isRTL;
        if (this.element) {
            this.renderer.setAttribute(this.element.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');
        }
    }
    get isRTL() {
        return Boolean(this.localizationService.rtl);
    }
}
ChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartComponent, deps: [{ token: ConfigurationService }, { token: ThemeService }, { token: i0.ElementRef }, { token: i3.IntlService }, { token: i4.LocalizationService }, { token: i0.NgZone }, { token: InstanceEventService }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
ChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ChartComponent, selector: "kendo-chart", inputs: { pannable: "pannable", renderAs: "renderAs", seriesColors: "seriesColors", subtitle: "subtitle", title: "title", transitions: "transitions", zoomable: "zoomable", axisDefaults: "axisDefaults", categoryAxis: "categoryAxis", chartArea: "chartArea", legend: "legend", panes: "panes", paneDefaults: "paneDefaults", plotArea: "plotArea", series: "series", seriesDefaults: "seriesDefaults", tooltip: "tooltip", valueAxis: "valueAxis", xAxis: "xAxis", yAxis: "yAxis", resizeRateLimit: "resizeRateLimit", popupSettings: "popupSettings" }, outputs: { axisLabelClick: "axisLabelClick", drag: "drag", dragEnd: "dragEnd", dragStart: "dragStart", legendItemHover: "legendItemHover", legendItemLeave: "legendItemLeave", noteClick: "noteClick", noteHover: "noteHover", noteLeave: "noteLeave", paneRender: "paneRender", plotAreaClick: "plotAreaClick", plotAreaHover: "plotAreaHover", plotAreaLeave: "plotAreaLeave", render: "render", select: "select", selectEnd: "selectEnd", selectStart: "selectStart", seriesClick: "seriesClick", seriesHover: "seriesHover", seriesOver: "seriesOver", seriesLeave: "seriesLeave", zoom: "zoom", zoomEnd: "zoomEnd", zoomStart: "zoomStart", legendItemClick: "legendItemClick" }, providers: [
        ConfigurationService,
        TooltipTemplateService,
        InstanceEventService,
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.chart'
        }
    ], queries: [{ propertyName: "donutCenterTemplate", first: true, predicate: DonutCenterTemplateDirective, descendants: true }, { propertyName: "seriesComponents", predicate: SeriesItemComponent, descendants: true }], viewQueries: [{ propertyName: "tooltipInstance", first: true, predicate: TooltipPopupComponent, descendants: true, static: true }, { propertyName: "crossahirTooltips", first: true, predicate: CrosshairTooltipsContainerComponent, descendants: true, static: true }, { propertyName: "surfaceElement", first: true, predicate: ["surface"], descendants: true, static: true }], exportAs: ["kendoChart"], usesOnChanges: true, ngImport: i0, template: `
    <div #surface class="k-chart-surface"></div>
    <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
    </kendo-chart-crosshair-tooltips-container>
    <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
    </kendo-chart-tooltip-popup>
    <kendo-resize-sensor (resize)="onResize()" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
    <div class="k-chart-donut-center" [ngStyle]="donutCenterStyle" *ngIf="donutCenterStyle && donutCenterTemplate">
      <ng-template [ngTemplateOutlet]="donutCenterTemplate.templateRef"></ng-template>
    </div>
  `, isInline: true, components: [{ type: CrosshairTooltipsContainerComponent, selector: "kendo-chart-crosshair-tooltips-container", inputs: ["popupSettings"] }, { type: TooltipPopupComponent, selector: "kendo-chart-tooltip-popup", inputs: ["animate", "classNames", "popupSettings", "wrapperClass"], outputs: ["leave"] }, { type: i8.ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }], directives: [{ type: i4$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4$1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i4$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'kendoChart',
                    providers: [
                        ConfigurationService,
                        TooltipTemplateService,
                        InstanceEventService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.chart'
                        }
                    ],
                    selector: 'kendo-chart',
                    template: `
    <div #surface class="k-chart-surface"></div>
    <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
    </kendo-chart-crosshair-tooltips-container>
    <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
    </kendo-chart-tooltip-popup>
    <kendo-resize-sensor (resize)="onResize()" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
    <div class="k-chart-donut-center" [ngStyle]="donutCenterStyle" *ngIf="donutCenterStyle && donutCenterTemplate">
      <ng-template [ngTemplateOutlet]="donutCenterTemplate.templateRef"></ng-template>
    </div>
  `
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: i0.ElementRef }, { type: i3.IntlService }, { type: i4.LocalizationService }, { type: i0.NgZone }, { type: InstanceEventService }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { pannable: [{
                type: Input
            }], renderAs: [{
                type: Input
            }], seriesColors: [{
                type: Input
            }], subtitle: [{
                type: Input
            }], title: [{
                type: Input
            }], transitions: [{
                type: Input
            }], zoomable: [{
                type: Input
            }], axisDefaults: [{
                type: Input
            }], categoryAxis: [{
                type: Input
            }], chartArea: [{
                type: Input
            }], legend: [{
                type: Input
            }], panes: [{
                type: Input
            }], paneDefaults: [{
                type: Input
            }], plotArea: [{
                type: Input
            }], series: [{
                type: Input
            }], seriesDefaults: [{
                type: Input
            }], tooltip: [{
                type: Input
            }], valueAxis: [{
                type: Input
            }], xAxis: [{
                type: Input
            }], yAxis: [{
                type: Input
            }], axisLabelClick: [{
                type: Output
            }], drag: [{
                type: Output
            }], dragEnd: [{
                type: Output
            }], dragStart: [{
                type: Output
            }], legendItemHover: [{
                type: Output
            }], legendItemLeave: [{
                type: Output
            }], noteClick: [{
                type: Output
            }], noteHover: [{
                type: Output
            }], noteLeave: [{
                type: Output
            }], paneRender: [{
                type: Output
            }], plotAreaClick: [{
                type: Output
            }], plotAreaHover: [{
                type: Output
            }], plotAreaLeave: [{
                type: Output
            }], render: [{
                type: Output
            }], select: [{
                type: Output
            }], selectEnd: [{
                type: Output
            }], selectStart: [{
                type: Output
            }], seriesClick: [{
                type: Output
            }], seriesHover: [{
                type: Output
            }], seriesOver: [{
                type: Output
            }], seriesLeave: [{
                type: Output
            }], zoom: [{
                type: Output
            }], zoomEnd: [{
                type: Output
            }], zoomStart: [{
                type: Output
            }], legendItemClick: [{
                type: Output
            }], resizeRateLimit: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], seriesComponents: [{
                type: ContentChildren,
                args: [SeriesItemComponent, { descendants: true }]
            }], donutCenterTemplate: [{
                type: ContentChild,
                args: [DonutCenterTemplateDirective, { static: false }]
            }], tooltipInstance: [{
                type: ViewChild,
                args: [TooltipPopupComponent, { static: true }]
            }], crossahirTooltips: [{
                type: ViewChild,
                args: [CrosshairTooltipsContainerComponent, { static: true }]
            }], surfaceElement: [{
                type: ViewChild,
                args: ['surface', { static: true }]
            }] } });

/**
 * The default options for all Chart axes.
 * Accepts the options which are supported by [`categoryAxis`]({% slug api_charts_categoryaxisitemcomponent %}),
 * [`valueAxis`]({% slug api_charts_valueaxisitemcomponent %}),
 * [`xAxis`]({% slug api_charts_xaxisitemcomponent %}),
 * and [`yAxis`]({% slug api_charts_yaxisitemcomponent %}).
 *
 * @example
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *  <div style="height: 600px;">
 *  <kendo-chart [categoryAxis]="{ categories: categories }" [chartArea]="{height: 600}" >
 *    <kendo-chart-axis-defaults
 *      [background]="background"
 *      [color]="color"
 *      [crosshair]="crosshair"
 *      [labels]="labels"
 *      [line]="line"
 *      [majorGridLines]="majorGridLines"
 *      [minorGridLines]="minorGridLines"
 *      [majorTicks]="majorTicks"
 *      [minorTicks]="minorTicks"
 *      [title]="title"
 *      ></kendo-chart-axis-defaults>
 *    <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *    <kendo-chart-legend position="bottom" orientation="horizontal"></kendo-chart-legend>
 *    <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *    <kendo-chart-series>
 *        <kendo-chart-series-item *ngFor="let item of series"
 *            type="line" style="smooth" [data]="item.data" [name]="item.name">
 *        </kendo-chart-series-item>
 *    </kendo-chart-series>
 *  </kendo-chart>
 *  </div>
 * `
 * })
 * export class AppComponent {
 * public series: any[] = [{
 * name: "India",
 * data: [4, 8, 8, 9, 9, 9, 3, 8, 9, 6]
 * }, {
 * name: "Russian Federation",
 * data: [4, 7, 7, 6, 8, 8, 5, 8, 4, 4]
 * }, {
 * name: "Germany",
 * data: [0, 0, 1, 1, 4, 3, 1, 5, 4, 3]
 * },{
 * name: "World",
 * data: [2, 3, 4, 4, 4, 4, 1, 2, 4, 3]
 * }];
 *
 * public  categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 *
 * public background = 'white';
 * // public color = 'cyan'; // will override the line.color option
 * public crosshair = {
 * visible: true
 * };
 * public labels = {
 * font: 'bold 12px/30px Helvetica, Arial, sans-serif',
 * color: '#4CAF50',
 * padding: 5,
 * rotation: 45,
 * background: 'white',
 * border: {
 * color: '#4CAF50',
 * width: 2
 * },
 * };
 * public line = {
 * color: 'black',
 * width: 3
 * };
 *
 * public majorGridLines = {
 * color: 'black',
 * visible: true
 * }
 *
 * public minorGridLines = {
 * color: 'lightgray',
 * visible: true
 * }
 *
 * public majorTicks = {
 * color: 'black',
 * size: 15
 * }
 *
 * public minorTicks = {
 * color: 'lightgray',
 * size: 10
 * }
 *
 * public title = {
 * text: 'Default Axis Title',
 * color: 'black',
 * background: 'white',
 * border: {
 * color: 'black',
 * width: 2
 * },
 * padding: 10
 * }
 * }
 * ```
 */
class AxisDefaultsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AxisDefaultsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AxisDefaultsComponent, selector: "kendo-chart-axis-defaults", inputs: { background: "background", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", minorGridLines: "minorGridLines", minorTicks: "minorTicks", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", startAngle: "startAngle", visible: "visible", crosshair: "crosshair", labels: "labels", title: "title" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-axis-defaults',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], color: [{
                type: Input
            }], line: [{
                type: Input
            }], majorGridLines: [{
                type: Input
            }], majorTicks: [{
                type: Input
            }], minorGridLines: [{
                type: Input
            }], minorTicks: [{
                type: Input
            }], narrowRange: [{
                type: Input
            }], pane: [{
                type: Input
            }], plotBands: [{
                type: Input
            }], reverse: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], visible: [{
                type: Input
            }], crosshair: [{
                type: Input
            }], labels: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * The crosshair configuration options ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
class AxisDefaultsCrosshairComponent extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.crosshair', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
AxisDefaultsCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AxisDefaultsCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AxisDefaultsCrosshairComponent, selector: "kendo-chart-axis-defaults-crosshair", inputs: { color: "color", dashType: "dashType", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-axis-defaults-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], dashType: [{
                type: Input
            }], opacity: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the [`axisDefaults.crosshair.tooltip.visible`]({% slug api_charts_axisdefaultscrosshairtooltipcomponent %}#toc-visible)
 * option is set to `true`.
 */
class AxisDefaultsCrosshairTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
AxisDefaultsCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AxisDefaultsCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AxisDefaultsCrosshairTooltipComponent, selector: "kendo-chart-axis-defaults-crosshair-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-axis-defaults-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration of the axis labels ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
class AxisDefaultsLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.labels', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AxisDefaultsLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AxisDefaultsLabelsComponent, selector: "kendo-chart-axis-defaults-labels", inputs: { content: "content", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-axis-defaults-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], mirror: [{
                type: Input
            }], padding: [{
                type: Input
            }], rotation: [{
                type: Input
            }], skip: [{
                type: Input
            }], step: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the axis title ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
class AxisDefaultsTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.title', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
AxisDefaultsTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: AxisDefaultsTitleComponent, selector: "kendo-chart-axis-defaults-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AxisDefaultsTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-axis-defaults-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class CollectionComponent {
    constructor(configKey, configurationService, collectionService) {
        this.configKey = configKey;
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.items = [];
        this.subscription = collectionService.onItemChange$.subscribe(changes => this.processChanges(changes));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    ngAfterContentInit() {
        this.readItems();
        this.children.changes.subscribe(() => this.readItems());
    }
    processChanges(changes) {
        if (!this.children) {
            return;
        }
        const index = this.children.toArray().indexOf(changes.sender);
        if (index < 0) {
            return;
        }
        this.items[index] = changes.options;
        this.change();
    }
    readItems() {
        this.items = this.children.map(s => s.options);
        this.change();
    }
    change() {
        this.configurationService.notify(new Change(this.configKey, this.items.length === 0 ? undefined : this.items));
    }
}
CollectionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionComponent, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
CollectionComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.12", type: CollectionComponent, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CollectionComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }, { type: ConfigurationService }, { type: CollectionService }]; } });

/**
 * The configuration component for a category axis ([see example]({% slug axes_chart_charts %})).
 */
class CategoryAxisItemComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });
    }
}
CategoryAxisItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }, { token: i3.IntlService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisItemComponent, selector: "kendo-chart-category-axis-item", inputs: { autoBaseUnitSteps: "autoBaseUnitSteps", axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", baseUnitStep: "baseUnitStep", categories: "categories", color: "color", justified: "justified", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", max: "max", maxDateGroups: "maxDateGroups", maxDivisions: "maxDivisions", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", name: "name", pane: "pane", plotBands: "plotBands", reverse: "reverse", roundToBaseUnit: "roundToBaseUnit", startAngle: "startAngle", type: "type", visible: "visible", weekStartDay: "weekStartDay", crosshair: "crosshair", labels: "labels", notes: "notes", select: "select", title: "title", rangeLabels: "rangeLabels" }, providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-category-axis-item',
                    template: ''
                }]
        }], ctorParameters: function () {
        return [{ type: ConfigurationService }, { type: CollectionService }, { type: i3.IntlService }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [LOCALE_ID]
                    }] }];
    }, propDecorators: { autoBaseUnitSteps: [{
                type: Input
            }], axisCrossingValue: [{
                type: Input
            }], background: [{
                type: Input
            }], baseUnit: [{
                type: Input
            }], baseUnitStep: [{
                type: Input
            }], categories: [{
                type: Input
            }], color: [{
                type: Input
            }], justified: [{
                type: Input
            }], line: [{
                type: Input
            }], majorGridLines: [{
                type: Input
            }], majorTicks: [{
                type: Input
            }], max: [{
                type: Input
            }], maxDateGroups: [{
                type: Input
            }], maxDivisions: [{
                type: Input
            }], min: [{
                type: Input
            }], minorGridLines: [{
                type: Input
            }], minorTicks: [{
                type: Input
            }], name: [{
                type: Input
            }], pane: [{
                type: Input
            }], plotBands: [{
                type: Input
            }], reverse: [{
                type: Input
            }], roundToBaseUnit: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }], weekStartDay: [{
                type: Input
            }], crosshair: [{
                type: Input
            }], labels: [{
                type: Input
            }], notes: [{
                type: Input
            }], select: [{
                type: Input
            }], title: [{
                type: Input
            }], rangeLabels: [{
                type: Input
            }] } });

/**
 * A collection of one or more category axis items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-category-axis>
 *         <kendo-chart-category-axis-item [categories]="[2015, 2016]" color="#f00">
 *         </kendo-chart-category-axis-item>
 *       </kendo-chart-category-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 * ```
 */
class CategoryAxisComponent extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('categoryAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
CategoryAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisComponent, selector: "kendo-chart-category-axis", providers: [CollectionService], queries: [{ propertyName: "children", predicate: CategoryAxisItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-category-axis',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [CategoryAxisItemComponent]
            }] } });

/**
 * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).
 */
class CategoryAxisCrosshairComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
CategoryAxisCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisCrosshairComponent, selector: "kendo-chart-category-axis-item-crosshair", inputs: { color: "color", dashType: "dashType", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], dashType: [{
                type: Input
            }], opacity: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
class CategoryAxisCrosshairTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
CategoryAxisCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisCrosshairTooltipComponent, selector: "kendo-chart-category-axis-item-crosshair-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration of the axis labels ([see example]({% slug labels_chart_charts %})).
 */
class CategoryAxisLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisLabelsComponent, selector: "kendo-chart-category-axis-item-labels", inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], culture: [{
                type: Input
            }], dateFormats: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], mirror: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], skip: [{
                type: Input
            }], step: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the axis date range labels ([see example]({% slug labels_chart_charts %})).
 */
class CategoryAxisRangeLabelsComponent extends CategoryAxisLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.configKey = 'rangeLabels';
        this.markAsVisible();
    }
}
CategoryAxisRangeLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisRangeLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisRangeLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisRangeLabelsComponent, selector: "kendo-chart-category-axis-item-range-labels", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisRangeLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-range-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The configuration of the category axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).
 */
class CategoryAxisNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisNotesComponent, selector: "kendo-chart-category-axis-item-notes", inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { data: [{
                type: Input
            }], line: [{
                type: Input
            }], position: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class CategoryAxisNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisNotesIconComponent, selector: "kendo-chart-category-axis-item-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class CategoryAxisNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisNotesLabelComponent, selector: "kendo-chart-category-axis-item-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.
 * Categories with indexes in the
 * ([`select.from`]({% slug api_charts_categoryaxisselectcomponent %}#toc-from)
 * &mdash;[`select.to`]({% slug api_charts_categoryaxisselectcomponent %}#toc-to)) range will be selected.
 * This means that the last category in the range will not be included in the selection.
 * If the categories are dates, the range has to be also specified with date values.
 */
class CategoryAxisSelectComponent extends SettingsComponent {
    constructor(configurationService) {
        super('select', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisSelectComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisSelectComponent, selector: "kendo-chart-category-axis-item-select", inputs: { from: "from", max: "max", min: "min", mousewheel: "mousewheel", to: "to" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisSelectComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-select',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { from: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], mousewheel: [{
                type: Input
            }], to: [{
                type: Input
            }] } });

/**
 * The configuration of the category axis title.
 */
class CategoryAxisTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryAxisTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: CategoryAxisTitleComponent, selector: "kendo-chart-category-axis-item-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: CategoryAxisTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-category-axis-item-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart area.
 * Represents the entire visible area of the Chart
 * ([see example]({% slug chartarea_chart_charts %})).
 */
class ChartAreaComponent extends SettingsComponent {
    constructor(configurationService) {
        super('chartArea', configurationService);
        this.configurationService = configurationService;
    }
}
ChartAreaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartAreaComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ChartAreaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ChartAreaComponent, selector: "kendo-chart-area", inputs: { background: "background", border: "border", height: "height", margin: "margin", opacity: "opacity", width: "width" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartAreaComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-area',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], height: [{
                type: Input
            }], margin: [{
                type: Input
            }], opacity: [{
                type: Input
            }], width: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart legend
 * ([see example]({% slug legend_chart_charts %})).
 */
class LegendComponent extends SettingsComponent {
    constructor(configurationService) {
        super('legend', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
LegendComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
LegendComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: LegendComponent, selector: "kendo-chart-legend", inputs: { align: "align", background: "background", border: "border", height: "height", labels: "labels", margin: "margin", offsetX: "offsetX", offsetY: "offsetY", orientation: "orientation", padding: "padding", position: "position", reverse: "reverse", visible: "visible", width: "width", markers: "markers", spacing: "spacing", inactiveItems: "inactiveItems", item: "item", title: "title" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-legend',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { align: [{
                type: Input
            }], background: [{
                type: Input
            }], border: [{
                type: Input
            }], height: [{
                type: Input
            }], labels: [{
                type: Input
            }], margin: [{
                type: Input
            }], offsetX: [{
                type: Input
            }], offsetY: [{
                type: Input
            }], orientation: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], reverse: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], markers: [{
                type: Input
            }], spacing: [{
                type: Input
            }], inactiveItems: [{
                type: Input
            }], item: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * The configuration of the inactive Chart legend items.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-legend>
 *      <kendo-chart-legend-inactive-items [labels]="{color: 'pink'}"></kendo-chart-legend-inactive-items>
 *   </kendo-chart-legend>
 * </kendo-chart>
 * ```
 */
class LegendInactiveItemsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('legend.inactiveItems', configurationService);
        this.configurationService = configurationService;
    }
}
LegendInactiveItemsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendInactiveItemsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
LegendInactiveItemsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: LegendInactiveItemsComponent, selector: "kendo-chart-legend-inactive-items", inputs: { labels: "labels" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendInactiveItemsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-legend-inactive-items',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { labels: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart legend item.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-legend>
 *      <kendo-chart-legend-item cursor="crosshair"></kendo-chart-legend-item>
 *   </kendo-chart-legend>
 * </kendo-chart>
 * ```
 */
class LegendItemComponent extends SettingsComponent {
    constructor(configurationService) {
        super('legend.item', configurationService);
        this.configurationService = configurationService;
    }
}
LegendItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendItemComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
LegendItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: LegendItemComponent, selector: "kendo-chart-legend-item", inputs: { cursor: "cursor", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: LegendItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-legend-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { cursor: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration component for a Chart pane.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-chart>
 *         <kendo-chart-panes>
 *             <kendo-chart-pane name="top" background="pink" [border]="{ color: 'black', dashtype: 'dash', width: 2 }">
 *               <!--            ^^^^^^^^^^
 *                   Unique ID for the pane.
 *               -->
 *             </kendo-chart-pane>
 *             <kendo-chart-pane name="bottom" [height]="150" title="Bottom pane">
 *               <!--                          ^^^^^^^^^^^^^^
 *                   Note that the binding is required,
 *                   otherwise the property will be
 *                   bound to a '100' string.
 *               -->
 *             </kendo-chart-pane>
 *         </kendo-chart-panes>
 *
 *         <kendo-chart-value-axis>
 *             <kendo-chart-value-axis-item name="top">
 *               <!--                       ^^^^^^^^^^
 *                   Unique ID for the axis.
 *                   No need to set a pane as it will use the first,
 *                   'top' pane by default.
 *               -->
 *             </kendo-chart-value-axis-item>
 *             <kendo-chart-value-axis-item name="bottom"
 *                                          pane="bottom">
 *               <!--                       ^^^^^^^^^^^^^
 *                   Move the axis to the bottom pane.
 *               -->
 *             </kendo-chart-value-axis-item>
 *         </kendo-chart-value-axis>
 *         <kendo-chart-series>
 *           <kendo-chart-series-item [data]="seriesData[0]">
 *               <!-- Will use the first, 'top' value axis by default. -->
 *           </kendo-chart-series-item>
 *           <kendo-chart-series-item type="line" [data]="seriesData[1]" axis="bottom">
 *               <!-- Plot this series to the 'bottom' axis.              ^^^^^^^^^^^^^ -->
 *           </kendo-chart-series-item>
 *         </kendo-chart-series>
 *       </kendo-chart>
 *   `
 * })
 * export class AppComponent {
 *   public seriesData: number[][] = [[1, 2, 3, 5], [0, 1, 0, 1]];
 * }
 * ```
 */
class PaneComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
PaneComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
PaneComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PaneComponent, selector: "kendo-chart-pane, kendo-chart-panes-item", inputs: { background: "background", border: "border", clip: "clip", height: "height", margin: "margin", name: "name", padding: "padding", title: "title" }, providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-pane, kendo-chart-panes-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], clip: [{
                type: Input
            }], height: [{
                type: Input
            }], margin: [{
                type: Input
            }], name: [{
                type: Input
            }], padding: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * The default options for all chart panes,
 * ([see example]({% slug panes_chart_charts %}#toc-default-panes-configuration)).
 */
class PaneDefaultsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('paneDefaults', configurationService);
        this.configurationService = configurationService;
    }
}
PaneDefaultsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneDefaultsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
PaneDefaultsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PaneDefaultsComponent, selector: "kendo-chart-pane-defaults", inputs: { background: "background", border: "border", clip: "clip", height: "height", margin: "margin", padding: "padding", title: "title" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneDefaultsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-pane-defaults',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], clip: [{
                type: Input
            }], height: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * The configuration of the pane default title.
 */
class PaneDefaultsTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('paneDefaults.title', configurationService);
        this.configurationService = configurationService;
    }
}
PaneDefaultsTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneDefaultsTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
PaneDefaultsTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PaneDefaultsTitleComponent, selector: "kendo-chart-pane-defaults-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", position: "position", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PaneDefaultsTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-pane-defaults-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], position: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * A collection of one or more pane configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-panes>
 *         <kendo-chart-pane name="topPane">
 *         </kendo-chart-pane>
 *         <kendo-chart-pane name="bottomPane">
 *         </kendo-chart-pane>
 *       </kendo-chart-panes>
 *       <kendo-chart-value-axis>
 *         <kendo-chart-value-axis-item pane="topPane">
 *         </kendo-chart-value-axis-item>
 *         <kendo-chart-value-axis-item name="bottomAxis" pane="bottomPane">
 *         </kendo-chart-value-axis-item>
 *       </kendo-chart-value-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3, 4]"
 *                                  axis="bottomAxis">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
class PanesComponent extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('panes', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
PanesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PanesComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
PanesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PanesComponent, selector: "kendo-chart-panes", providers: [CollectionService], queries: [{ propertyName: "children", predicate: PaneComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PanesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-panes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [PaneComponent]
            }] } });

/**
 * The configuration of the Chart pane title.
 */
class PanesTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
PanesTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PanesTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
PanesTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PanesTitleComponent, selector: "kendo-chart-pane-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", position: "position", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PanesTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-pane-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], position: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration options of the plot area
 * ([see example]({% slug plotarea_chart_charts %})).
 * The plot area is the area which displays the series.
 */
class PlotAreaComponent extends SettingsComponent {
    constructor(configurationService) {
        super('plotArea', configurationService);
        this.configurationService = configurationService;
    }
}
PlotAreaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PlotAreaComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
PlotAreaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: PlotAreaComponent, selector: "kendo-chart-plot-area", inputs: { background: "background", border: "border", margin: "margin", opacity: "opacity", padding: "padding" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PlotAreaComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-plot-area',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], margin: [{
                type: Input
            }], opacity: [{
                type: Input
            }], padding: [{
                type: Input
            }] } });

/**
 * A collection of one or more series items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
class SeriesComponent extends CollectionComponent {
    constructor(configurationService, collectionService, tooltipTemplateService) {
        super('series', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.tooltipTemplateService = tooltipTemplateService;
    }
    ngAfterContentChecked() {
        this.readTooltipTemplates();
    }
    readTooltipTemplates() {
        const templates = this.children.map((item) => item.seriesTooltipTemplateRef);
        this.tooltipTemplateService.setSeriesTemplates(templates);
    }
}
SeriesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }, { token: TooltipTemplateService }], target: i0.ɵɵFactoryTarget.Component });
SeriesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesComponent, selector: "kendo-chart-series", providers: [CollectionService], queries: [{ propertyName: "children", predicate: SeriesItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-series',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: TooltipTemplateService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [SeriesItemComponent]
            }] } });

/**
 * The default options for all series
 * ([see example]({% slug series_chart_charts %}#toc-default-series-configuration)).
 */
class SeriesDefaultsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsComponent, selector: "kendo-chart-series-defaults", inputs: { border: "border", gap: "gap", highlight: "highlight", overlay: "overlay", spacing: "spacing", stack: "stack", type: "type", visual: "visual", labels: "labels", notes: "notes", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { border: [{
                type: Input
            }], gap: [{
                type: Input
            }], highlight: [{
                type: Input
            }], overlay: [{
                type: Input
            }], spacing: [{
                type: Input
            }], stack: [{
                type: Input
            }], type: [{
                type: Input
            }], visual: [{
                type: Input
            }], labels: [{
                type: Input
            }], notes: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart series label.
 */
class SeriesDefaultsLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesDefaultsLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsLabelsComponent, selector: "kendo-chart-series-defaults-labels", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible", visual: "visual", from: "from", to: "to" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }], from: [{
                type: Input
            }], to: [{
                type: Input
            }] } });

/**
 * The `from` label configuration of the Chart series.
 */
class SeriesDefaultsLabelsFromComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels.from', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesDefaultsLabelsFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsFromComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsLabelsFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsLabelsFromComponent, selector: "kendo-chart-series-defaults-labels-from", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsFromComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-labels-from',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The `to` label configuration of the Chart series.
 */
class SeriesDefaultsLabelsToComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels.to', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesDefaultsLabelsToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsToComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsLabelsToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsLabelsToComponent, selector: "kendo-chart-series-defaults-labels-to", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsLabelsToComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-labels-to',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration of the [`seriesDefaults`]({% slug api_charts_seriesdefaultscomponent %}) notes.
 */
class SeriesDefaultsNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsNotesComponent, selector: "kendo-chart-series-defaults-notes", inputs: { line: "line", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { line: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class SeriesDefaultsNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsNotesIconComponent, selector: "kendo-chart-series-defaults-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class SeriesDefaultsNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsNotesLabelComponent, selector: "kendo-chart-series-defaults-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart series tooltip.
 */
class SeriesDefaultsTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesDefaultsTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesDefaultsTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesDefaultsTooltipComponent, selector: "kendo-chart-series-defaults-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesDefaultsTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-defaults-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The error bars of the Chart series
 * ([see example]({% slug errorbars_chart_charts %})).
 */
class SeriesErrorBarsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('errorBars', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesErrorBarsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesErrorBarsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesErrorBarsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesErrorBarsComponent, selector: "kendo-chart-series-item-error-bars", inputs: { color: "color", endCaps: "endCaps", line: "line", value: "value", visual: "visual", xValue: "xValue", yValue: "yValue" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesErrorBarsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-error-bars',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], endCaps: [{
                type: Input
            }], line: [{
                type: Input
            }], value: [{
                type: Input
            }], visual: [{
                type: Input
            }], xValue: [{
                type: Input
            }], yValue: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart series extremes.
 * Applies to extreme outliers.
 * For more information, refer to [`series.outliers`]({% slug api_charts_seriesitemcomponent %}#toc-outliers).
 */
class SeriesExtremesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('extremes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesExtremesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesExtremesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesExtremesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesExtremesComponent, selector: "kendo-chart-series-item-extremes", inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesExtremesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-extremes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], rotation: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }] } });

/**
 * The Chart series highlighting configuration options.
 */
class SeriesHighlightComponent extends SettingsComponent {
    constructor(configurationService) {
        super('highlight', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesHighlightComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesHighlightComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesHighlightComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesHighlightComponent, selector: "kendo-chart-series-item-highlight", inputs: { border: "border", color: "color", line: "line", markers: "markers", opacity: "opacity", toggle: "toggle", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesHighlightComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-highlight',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { border: [{
                type: Input
            }], color: [{
                type: Input
            }], line: [{
                type: Input
            }], markers: [{
                type: Input
            }], opacity: [{
                type: Input
            }], toggle: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart series label
 * ([see example]({% slug labels_chart_charts %})).
 */
class SeriesLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesLabelsComponent, selector: "kendo-chart-series-item-labels", inputs: { align: "align", background: "background", border: "border", color: "color", content: "content", distance: "distance", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", rotation: "rotation", visible: "visible", visual: "visual", from: "from", to: "to" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { align: [{
                type: Input
            }], background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], distance: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }], from: [{
                type: Input
            }], to: [{
                type: Input
            }] } });

/**
 * The `from` label configuration of the Chart series.
 */
class SeriesLabelsFromComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels.from', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesLabelsFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsFromComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesLabelsFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesLabelsFromComponent, selector: "kendo-chart-series-item-labels-from", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsFromComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-labels-from',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The `to` label configuration of the Chart series.
 */
class SeriesLabelsToComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels.to', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
SeriesLabelsToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsToComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesLabelsToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesLabelsToComponent, selector: "kendo-chart-series-item-labels-to", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesLabelsToComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-labels-to',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart series marker.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *       selector: 'my-app',
 *   template: `
 *       <kendo-chart [categoryAxis]="{ categories: categories }">
 *           <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *           <kendo-chart-legend position="bottom" orientation="horizontal"></kendo-chart-legend>
 *           <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *           <kendo-chart-series>
 *               <kendo-chart-series-item *ngFor="let item of series"
 *                   type="line"
 *                   style="smooth"
 *                   [data]="item.data"
 *                   [name]="item.name"
 *                   [markers]="item.markers">
 *               </kendo-chart-series-item>
 *           </kendo-chart-series>
 *       </kendo-chart>
 *   `
 * })
 * export class AppComponent {
 * public series: any[] = [{
 *   name: "India",
 *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855],
 *   markers: {
 *     background: 'red',
 *     size: 20,
 *     type: 'circle'
 *   }
 * }, {
 *   name: "Russian Federation",
 *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3],
 *   markers: {
 *     background: 'yellow',
 *     size: 10,
 *     type: 'square',
 *     rotation: 45
 *   }
 * }, {
 *   name: "Germany",
 *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995],
 *   markers: {
 *     background: 'green',
 *     size: 20,
 *     type: 'triangle'
 *   }
 * },{
 *   name: "World",
 *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727],
 *   markers: {
 *     background: 'blue',
 *     size: 10,
 *     type: 'cross'
 *   }
 * }];
 * public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 * }
 * ```
 */
class SeriesMarkersComponent extends SettingsComponent {
    constructor(configurationService) {
        super('markers', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesMarkersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesMarkersComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesMarkersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesMarkersComponent, selector: "kendo-chart-series-item-markers", inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type", visible: "visible", visual: "visual", from: "from", to: "to" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesMarkersComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-markers',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], rotation: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }], from: [{
                type: Input
            }], to: [{
                type: Input
            }] } });

/**
 * The series notes configuration
 * ([see example]({% slug notes_chart_charts %})).
 */
class SeriesNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesNotesComponent, selector: "kendo-chart-series-item-notes", inputs: { line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { line: [{
                type: Input
            }], position: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class SeriesNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesNotesIconComponent, selector: "kendo-chart-series-item-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class SeriesNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesNotesLabelComponent, selector: "kendo-chart-series-item-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration of the Chart series outliers.
 * Applies to mild outliers.
 * For more information, refer to the [`series.extremes`]({% slug api_charts_seriesitemcomponent %}#toc-extremes) option.
 */
class SeriesOutliersComponent extends SettingsComponent {
    constructor(configurationService) {
        super('outliers', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesOutliersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesOutliersComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SeriesOutliersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SeriesOutliersComponent, selector: "kendo-chart-series-item-outliers", inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SeriesOutliersComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-series-item-outliers',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], rotation: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart subtitle or text
 * ([see example]({% slug title_chart_charts %})).
 *
 * @example
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-chart [categoryAxis]="{ categories: categories }">
 *            <kendo-chart-title text="Gross domestic product growth"></kendo-chart-title>
 *            <kendo-chart-subtitle text="/GDP annual %/"></kendo-chart-subtitle>
 *            <kendo-chart-legend
 *              position="bottom"
 *              orientation="horizontal"
 *              align="end"
 *              background="rgba(255, 0, 0, 0.1)"
 *              [border]="borderOptions"
 *              [margin]="10"
 *              [padding]="10"
 *              [width]="150"
 *              [offsetX]="11"
 *              [offsetY]="-103"
 *              [reverse]="true"
 *              [visible]="isVisible"
 *              ></kendo-chart-legend>
 *            <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *            <kendo-chart-series>
 *                <kendo-chart-series-item *ngFor="let item of series"
 *                    type="line" style="smooth" [data]="item.data" [name]="item.name">
 *                </kendo-chart-series-item>
 *            </kendo-chart-series>
 *        </kendo-chart>
 *        <br /><br />
 *        <button kendoButton (click)="isVisible=!isVisible">Toggle Legend</button>
 *    `
 * })
 * export class AppComponent {
 *  public isVisible = true;
 *  public borderOptions = {
 *    color: "rgba(255, 0, 0, 0.8)",
 *    dashType: 'dash',
 *    width: 2
 *  };
 *
 * public series: any[] = [{
 *   name: "India",
 *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855]
 * }, {
 *   name: "Russian Federation",
 *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3]
 * }, {
 *   name: "Germany",
 *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995]
 * },{
 *   name: "World",
 *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727]
 * }];
 *  public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 * }
 * ```
 */
class SubtitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('subtitle', configurationService);
        this.configurationService = configurationService;
    }
}
SubtitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SubtitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
SubtitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SubtitleComponent, selector: "kendo-chart-subtitle", inputs: { align: "align", background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", text: "text", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SubtitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-subtitle',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { align: [{
                type: Input
            }], background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart title or text
 * ([see example]({% slug title_chart_charts %})).
 *
 * @example
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-chart [categoryAxis]="{ categories: categories }">
 *            <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *            <kendo-chart-legend
 *              position="bottom"
 *              orientation="horizontal"
 *              align="end"
 *              background="rgba(255, 0, 0, 0.1)"
 *              [border]="borderOptions"
 *              [margin]="10"
 *              [padding]="10"
 *              [width]="150"
 *              [offsetX]="11"
 *              [offsetY]="-103"
 *              [reverse]="true"
 *              [visible]="isVisible"
 *              ></kendo-chart-legend>
 *            <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *            <kendo-chart-series>
 *                <kendo-chart-series-item *ngFor="let item of series"
 *                    type="line" style="smooth" [data]="item.data" [name]="item.name">
 *                </kendo-chart-series-item>
 *            </kendo-chart-series>
 *        </kendo-chart>
 *        <br /><br />
 *        <button kendoButton (click)="isVisible=!isVisible">Toggle Legend</button>
 *    `
 * })
 * export class AppComponent {
 *  public isVisible = true;
 *  public borderOptions = {
 *    color: "rgba(255, 0, 0, 0.8)",
 *    dashType: 'dash',
 *    width: 2
 *  };
 *
 * public series: any[] = [{
 *   name: "India",
 *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855]
 * }, {
 *   name: "Russian Federation",
 *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3]
 * }, {
 *   name: "Germany",
 *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995]
 * },{
 *   name: "World",
 *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727]
 * }];
 *  public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 * }
 * ```
 */
class TitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
TitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
TitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: TitleComponent, selector: "kendo-chart-title", inputs: { align: "align", background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", text: "text", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { align: [{
                type: Input
            }], background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration options of the Chart series tooltip
 * ([see example]({% slug tooltips_chart_charts %})).
 */
class TooltipComponent extends SettingsComponent {
    constructor(configurationService, templateService) {
        super('tooltip', configurationService);
        this.configurationService = configurationService;
        this.templateService = templateService;
        this.markAsVisible();
    }
    ngAfterContentChecked() {
        this.templateService.setTemplate(this.seriesTooltipTemplate ? this.seriesTooltipTemplate.templateRef : null);
        this.templateService.setSharedTemplate(this.sharedTooltipTemplate ? this.sharedTooltipTemplate.templateRef : null);
    }
}
TooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipComponent, deps: [{ token: ConfigurationService }, { token: TooltipTemplateService }], target: i0.ɵɵFactoryTarget.Component });
TooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: TooltipComponent, selector: "kendo-chart-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", opacity: "opacity", padding: "padding", shared: "shared", visible: "visible" }, queries: [{ propertyName: "seriesTooltipTemplate", first: true, predicate: SeriesTooltipTemplateDirective, descendants: true }, { propertyName: "sharedTooltipTemplate", first: true, predicate: SharedTooltipTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: TooltipComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chart-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: TooltipTemplateService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], opacity: [{
                type: Input
            }], padding: [{
                type: Input
            }], shared: [{
                type: Input
            }], visible: [{
                type: Input
            }], seriesTooltipTemplate: [{
                type: ContentChild,
                args: [SeriesTooltipTemplateDirective, { static: false }]
            }], sharedTooltipTemplate: [{
                type: ContentChild,
                args: [SharedTooltipTemplateDirective, { static: false }]
            }] } });

/**
 * The configuration component for a value axis.
 */
class ValueAxisItemComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
ValueAxisItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisItemComponent, selector: "kendo-chart-value-axis-item", inputs: { axisCrossingValue: "axisCrossingValue", background: "background", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", type: "type", visible: "visible", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-value-axis-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { axisCrossingValue: [{
                type: Input
            }], background: [{
                type: Input
            }], color: [{
                type: Input
            }], line: [{
                type: Input
            }], majorGridLines: [{
                type: Input
            }], majorTicks: [{
                type: Input
            }], majorUnit: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], minorGridLines: [{
                type: Input
            }], minorTicks: [{
                type: Input
            }], minorUnit: [{
                type: Input
            }], name: [{
                type: Input
            }], narrowRange: [{
                type: Input
            }], pane: [{
                type: Input
            }], plotBands: [{
                type: Input
            }], reverse: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }], crosshair: [{
                type: Input
            }], labels: [{
                type: Input
            }], notes: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * A collection of one or more value axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-value-axis>
 *         <kendo-chart-value-axis-item>
 *         </kendo-chart-value-axis-item>
 *         <kendo-chart-value-axis-item name="secondAxis">
 *         </kendo-chart-value-axis-item>
 *       </kendo-chart-value-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item type="line" [data]="[0.1, 0.2, 0.3]"
 *                                  axis="secondAxis">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
class ValueAxisComponent extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('valueAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
ValueAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisComponent, selector: "kendo-chart-value-axis", providers: [CollectionService], queries: [{ propertyName: "children", predicate: ValueAxisItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-value-axis',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [ValueAxisItemComponent]
            }] } });

/**
 * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).
 */
class ValueAxisCrosshairComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
ValueAxisCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisCrosshairComponent, selector: "kendo-chart-value-axis-item-crosshair", inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], opacity: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The configuration options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
class ValueAxisCrosshairTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
ValueAxisCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisCrosshairTooltipComponent, selector: "kendo-chart-value-axis-item-crosshair-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The axis labels configuration.
 */
class ValueAxisLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisLabelsComponent, selector: "kendo-chart-value-axis-item-labels", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], mirror: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], skip: [{
                type: Input
            }], step: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the value axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).
 */
class ValueAxisNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisNotesComponent, selector: "kendo-chart-value-axis-item-notes", inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { data: [{
                type: Input
            }], line: [{
                type: Input
            }], position: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class ValueAxisNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisNotesIconComponent, selector: "kendo-chart-value-axis-item-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class ValueAxisNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisNotesLabelComponent, selector: "kendo-chart-value-axis-item-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The title configuration of the value axis.
 */
class ValueAxisTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ValueAxisTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ValueAxisTitleComponent, selector: "kendo-chart-value-axis-item-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ValueAxisTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-value-axis-item-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration component for an X axis
 * ([see example]({% slug api_charts_xaxiscomponent %})).
 */
class XAxisItemComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.intl = intl;
        this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });
    }
}
XAxisItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }, { token: i3.IntlService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
XAxisItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisItemComponent, selector: "kendo-chart-x-axis-item", inputs: { axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", categories: "categories", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", startAngle: "startAngle", type: "type", visible: "visible", weekStartDay: "weekStartDay", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-x-axis-item',
                    template: ''
                }]
        }], ctorParameters: function () {
        return [{ type: ConfigurationService }, { type: CollectionService }, { type: i3.IntlService }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [LOCALE_ID]
                    }] }];
    }, propDecorators: { axisCrossingValue: [{
                type: Input
            }], background: [{
                type: Input
            }], baseUnit: [{
                type: Input
            }], categories: [{
                type: Input
            }], color: [{
                type: Input
            }], line: [{
                type: Input
            }], majorGridLines: [{
                type: Input
            }], majorTicks: [{
                type: Input
            }], majorUnit: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], minorGridLines: [{
                type: Input
            }], minorTicks: [{
                type: Input
            }], minorUnit: [{
                type: Input
            }], name: [{
                type: Input
            }], narrowRange: [{
                type: Input
            }], pane: [{
                type: Input
            }], plotBands: [{
                type: Input
            }], reverse: [{
                type: Input
            }], startAngle: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }], weekStartDay: [{
                type: Input
            }], crosshair: [{
                type: Input
            }], labels: [{
                type: Input
            }], notes: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * A collection of one or more X-axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *  selector: 'my-app',
 * template: `
 *   <kendo-chart>
 *     <kendo-chart-x-axis>
 *       <kendo-chart-x-axis-item
 *         [background]="'rgba(100, 100, 100, 0.2)'"
 *         color="red"
 *         [notes]="notesConfig"
 *         [crosshair]="crosshairConfig">
 *       </kendo-chart-x-axis-item>
 *       <kendo-chart-x-axis-item name="secondAxis">
 *       </kendo-chart-x-axis-item>
 *     </kendo-chart-x-axis>
 *     <kendo-chart-series>
 *       <kendo-chart-series-item type="scatter" [data]="[[1, 2]]">
 *       </kendo-chart-series-item>
 *       <kendo-chart-series-item type="scatter" [data]="[[0.1, 0.2]]"
 *                                xAxis="secondAxis">
 *       </kendo-chart-series-item>
 *     </kendo-chart-series>
 *   </kendo-chart>
 * `
 * })
 * export class AppComponent {
 * public notesConfig = {
 *   data: [{
 *       value: 0.2,
 *       text: "foo"
 *     }, {
 *       value: 0.8,
 *       text: "bar"
 *     }],
 *   label: {
 *     content: (args: any) => args.dataItem.text,
 *     background: 'red',
 *     color: 'white'
 *   },
 *   line: {
 *     color: 'blue',
 *     dashType: 'dash',
 *     length: 150,
 *     width: 2
 *   },
 *   position: 'top'
 * };
 *
 * public crosshairConfig = {
 *   color: 'green',
 *   opacity: 0.8,
 *   visible: true,
 *   width: 3
 * };
 * }
 *
 * ```
 */
class XAxisComponent extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('xAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
XAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
XAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisComponent, selector: "kendo-chart-x-axis", providers: [CollectionService], queries: [{ propertyName: "children", predicate: XAxisItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-x-axis',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [XAxisItemComponent]
            }] } });

/**
 * The crosshair configuration options
 * ([see example]({% slug api_charts_xaxiscomponent %})).
 */
class XAxisCrosshairComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
XAxisCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisCrosshairComponent, selector: "kendo-chart-x-axis-item-crosshair", inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], opacity: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
class XAxisCrosshairTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
XAxisCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisCrosshairTooltipComponent, selector: "kendo-chart-x-axis-item-crosshair-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The axis labels configuration.
 */
class XAxisLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisLabelsComponent, selector: "kendo-chart-x-axis-item-labels", inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], culture: [{
                type: Input
            }], dateFormats: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], mirror: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], skip: [{
                type: Input
            }], step: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the X-axis notes.
 * For an example on the basic usage of the XAxisNotesComponent,
 * refer to the [demo on the XAxisComponent]({% slug api_charts_xaxiscomponent %})
 * or to the documentation about the
 * [axis notes]({% slug notes_chart_charts %}#toc-axis-notes).
 */
class XAxisNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisNotesComponent, selector: "kendo-chart-x-axis-item-notes", inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { data: [{
                type: Input
            }], line: [{
                type: Input
            }], position: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class XAxisNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisNotesIconComponent, selector: "kendo-chart-x-axis-item-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class XAxisNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisNotesLabelComponent, selector: "kendo-chart-x-axis-item-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The title configuration of the Scatter Chart X axis.
 */
class XAxisTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
XAxisTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: XAxisTitleComponent, selector: "kendo-chart-x-axis-item-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: XAxisTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-x-axis-item-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration component for the Y axis
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
class YAxisItemComponent extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
YAxisItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
YAxisItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisItemComponent, selector: "kendo-chart-y-axis-item", inputs: { axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", categories: "categories", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", type: "type", visible: "visible", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-y-axis-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { axisCrossingValue: [{
                type: Input
            }], background: [{
                type: Input
            }], baseUnit: [{
                type: Input
            }], categories: [{
                type: Input
            }], color: [{
                type: Input
            }], line: [{
                type: Input
            }], majorGridLines: [{
                type: Input
            }], majorTicks: [{
                type: Input
            }], majorUnit: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], minorGridLines: [{
                type: Input
            }], minorTicks: [{
                type: Input
            }], minorUnit: [{
                type: Input
            }], name: [{
                type: Input
            }], narrowRange: [{
                type: Input
            }], pane: [{
                type: Input
            }], plotBands: [{
                type: Input
            }], reverse: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }], crosshair: [{
                type: Input
            }], labels: [{
                type: Input
            }], notes: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * A collection of one or more Y-axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *  selector: 'my-app',
 *  template: `
 *    <kendo-chart>
 *     <kendo-chart-y-axis>
 *       <kendo-chart-y-axis-item
 *         [background]="'rgba(100, 100, 100, 0.2)'"
 *         color="red"
 *         [notes]="notesConfig"
 *         [crosshair]="crosshairConfig">
 *       </kendo-chart-y-axis-item>
 *       <kendo-chart-y-axis-item name="secondAxis">
 *       </kendo-chart-y-axis-item>
 *     </kendo-chart-y-axis>
 *     <kendo-chart-series>
 *       <kendo-chart-series-item type="scatter" [data]="[[1, 2]]">
 *       </kendo-chart-series-item>
 *       <kendo-chart-series-item type="scatter" [data]="[[0.1, 0.2]]"
 *                                yAxis="secondAxis">
 *       </kendo-chart-series-item>
 *     </kendo-chart-series>
 *   </kendo-chart>
 * `
 * })
 * export class AppComponent {
 * public notesConfig = {
 *   data: [{
 *       value: 0.2,
 *       text: "foo"
 *     }, {
 *       value: 0.8,
 *       text: "bar"
 *     }],
 *    label: {
 *     content: (args: any) => args.dataItem.text,
 *     background: 'red',
 *     color: 'white'
 *   },
 *   line: {
 *     color: 'blue',
 *     dashType: 'dash',
 *     length: 150,
 *     width: 2
 *   },
 *   position: 'top'
 * };
 *
 * public crosshairConfig = {
 *   color: 'green',
 *   opacity: 0.8,
 *   visible: true,
 *   width: 3
 * };
 * }
 *
 * ```
 */
class YAxisComponent extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('yAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
YAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
YAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisComponent, selector: "kendo-chart-y-axis", providers: [CollectionService], queries: [{ propertyName: "children", predicate: YAxisItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-y-axis',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [YAxisItemComponent]
            }] } });

/**
 * The crosshair configuration options
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
class YAxisCrosshairComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
YAxisCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisCrosshairComponent, selector: "kendo-chart-y-axis-item-crosshair", inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { color: [{
                type: Input
            }], opacity: [{
                type: Input
            }], visible: [{
                type: Input
            }], width: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
class YAxisCrosshairTooltipComponent extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
YAxisCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisCrosshairTooltipComponent, selector: "kendo-chart-y-axis-item-crosshair-tooltip", inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], padding: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The axis labels configuration.
 */
class YAxisLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisLabelsComponent, selector: "kendo-chart-y-axis-item-labels", inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], culture: [{
                type: Input
            }], dateFormats: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], margin: [{
                type: Input
            }], mirror: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], skip: [{
                type: Input
            }], step: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * The configuration of the Y axis notes
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
class YAxisNotesComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisNotesComponent, selector: "kendo-chart-y-axis-item-notes", inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { data: [{
                type: Input
            }], line: [{
                type: Input
            }], position: [{
                type: Input
            }], visual: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

/**
 * The icon of the notes.
 */
class YAxisNotesIconComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisNotesIconComponent, selector: "kendo-chart-y-axis-item-notes-icon", inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The label of the notes.
 */
class YAxisNotesLabelComponent extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisNotesLabelComponent, selector: "kendo-chart-y-axis-item-notes-label", inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], content: [{
                type: Input
            }], font: [{
                type: Input
            }], format: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The title configuration of the Scatter Chart Y axis.
 */
class YAxisTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
YAxisTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: YAxisTitleComponent, selector: "kendo-chart-y-axis-item-title", inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: YAxisTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-y-axis-item-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { background: [{
                type: Input
            }], border: [{
                type: Input
            }], color: [{
                type: Input
            }], font: [{
                type: Input
            }], margin: [{
                type: Input
            }], padding: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], text: [{
                type: Input
            }], visible: [{
                type: Input
            }], visual: [{
                type: Input
            }] } });

/**
 * Specifies if the Chart can be zoomed.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-zoomable [mousewheel]="false"></kendo-chart-zoomable>
 * </kendo-chart>
 * ```
 */
class ZoomableComponent extends SettingsComponent {
    constructor(configurationService) {
        super('zoomable', configurationService);
        this.configurationService = configurationService;
    }
}
ZoomableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ZoomableComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
ZoomableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ZoomableComponent, selector: "kendo-chart-zoomable", inputs: { mousewheel: "mousewheel", selection: "selection" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ZoomableComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-zoomable',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { mousewheel: [{
                type: Input
            }], selection: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const CHART_DIRECTIVES = [
    ChartComponent,
    TooltipPopupComponent,
    SeriesTooltipTemplateDirective,
    SharedTooltipTemplateDirective,
    CrosshairTooltipsContainerComponent,
    CrosshairTooltipComponent,
    DonutCenterTemplateDirective,
    AxisDefaultsComponent,
    AxisDefaultsCrosshairComponent,
    AxisDefaultsCrosshairTooltipComponent,
    AxisDefaultsLabelsComponent,
    AxisDefaultsTitleComponent,
    CategoryAxisComponent,
    CategoryAxisCrosshairComponent,
    CategoryAxisCrosshairTooltipComponent,
    CategoryAxisItemComponent,
    CategoryAxisLabelsComponent,
    CategoryAxisRangeLabelsComponent,
    CategoryAxisNotesComponent,
    CategoryAxisNotesIconComponent,
    CategoryAxisNotesLabelComponent,
    CategoryAxisSelectComponent,
    CategoryAxisTitleComponent,
    ChartAreaComponent,
    LegendComponent,
    LegendInactiveItemsComponent,
    LegendItemComponent,
    PaneComponent,
    PaneDefaultsComponent,
    PaneDefaultsTitleComponent,
    PanesComponent,
    PanesTitleComponent,
    PlotAreaComponent,
    SeriesComponent,
    SeriesDefaultsComponent,
    SeriesDefaultsLabelsComponent,
    SeriesDefaultsLabelsFromComponent,
    SeriesDefaultsLabelsToComponent,
    SeriesDefaultsNotesComponent,
    SeriesDefaultsNotesIconComponent,
    SeriesDefaultsNotesLabelComponent,
    SeriesDefaultsTooltipComponent,
    SeriesErrorBarsComponent,
    SeriesExtremesComponent,
    SeriesHighlightComponent,
    SeriesItemComponent,
    SeriesLabelsComponent,
    SeriesLabelsFromComponent,
    SeriesLabelsToComponent,
    SeriesMarkersComponent,
    SeriesNotesComponent,
    SeriesNotesIconComponent,
    SeriesNotesLabelComponent,
    SeriesOutliersComponent,
    SeriesTooltipComponent,
    SubtitleComponent,
    TitleComponent,
    TooltipComponent,
    ValueAxisComponent,
    ValueAxisCrosshairComponent,
    ValueAxisCrosshairTooltipComponent,
    ValueAxisItemComponent,
    ValueAxisLabelsComponent,
    ValueAxisNotesComponent,
    ValueAxisNotesIconComponent,
    ValueAxisNotesLabelComponent,
    ValueAxisTitleComponent,
    XAxisComponent,
    XAxisCrosshairComponent,
    XAxisCrosshairTooltipComponent,
    XAxisItemComponent,
    XAxisLabelsComponent,
    XAxisNotesComponent,
    XAxisNotesIconComponent,
    XAxisNotesLabelComponent,
    XAxisTitleComponent,
    YAxisComponent,
    YAxisCrosshairComponent,
    YAxisCrosshairTooltipComponent,
    YAxisItemComponent,
    YAxisLabelsComponent,
    YAxisNotesComponent,
    YAxisNotesIconComponent,
    YAxisNotesLabelComponent,
    YAxisTitleComponent,
    ZoomableComponent
];

// Re-export event types

/**
 * Specifies the `weekStartDay` of a [CategoryAxisItemComponent]({% slug api_charts_categoryaxisitemcomponent %}).
 */
var WeekStartDay;
(function (WeekStartDay) {
    /**
     * Specifies Sunday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Sunday"] = 0] = "Sunday";
    /**
     * Specifies Monday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Monday"] = 1] = "Monday";
    /**
     * Specifies Tuesday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Tuesday"] = 2] = "Tuesday";
    /**
     * Specifies Wednesday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Wednesday"] = 3] = "Wednesday";
    /**
     * Specifies Thursday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Thursday"] = 4] = "Thursday";
    /**
     * Specifies Friday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Friday"] = 5] = "Friday";
    /**
     * Specifies Saturday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Saturday"] = 6] = "Saturday";
})(WeekStartDay || (WeekStartDay = {}));

/**
 * The arguments for the `navigatorFilter` event.
 */
class NavigatorFilterEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.from = e.from;
        this.to = e.to;
    }
}

// Re-export event types

/**
 * @hidden
 */
class RootConfigurationService extends ConfigurationService {
}
RootConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: RootConfigurationService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RootConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: RootConfigurationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: RootConfigurationService, decorators: [{
            type: Injectable
        }] });

const EVENT_MAP = {
    navigatorFilter: NavigatorFilterEvent
};
/**
 * @hidden
 */
class StockInstanceEventService extends InstanceEventService {
    create(name, args, sender) {
        if (EVENT_MAP[name]) {
            return new EVENT_MAP[name](args, sender);
        }
        return super.create(name, args, sender);
    }
}

const NAVIGATOR_DEFAULTS = {
    autoBindElements: true,
    liveDrag: false,
    partialRedraw: true
};
/**
 * The root StockChart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-stockchart>
 *         <kendo-chart-series>
 *             <kendo-chart-series-item type="line" [data]="data" field="value" categoryField="date">
 *             </kendo-chart-series-item>
 *         </kendo-chart-series>
 *         <kendo-chart-navigator>
 *             <kendo-chart-navigator-select to="2017/02/01">
 *             </kendo-chart-navigator-select>
 *             <kendo-chart-navigator-series>
 *                 <kendo-chart-navigator-series-item type="area" [data]="data" field="value" categoryField="date">
 *                 </kendo-chart-navigator-series-item>
 *             </kendo-chart-navigator-series>
 *         </kendo-chart-navigator>
 *     </kendo-stockchart>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [];
 *
 *   constructor() {
 *      for (let idx = 0; idx < 100; idx++) {
 *          this.data.push({
 *              date: new Date(2017, 0, idx),
 *              value: Math.random() * 100
 *          });
 *      }
 *   }
 * }
 *
 * ```
 */
class StockChartComponent extends ChartComponent {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * Fires when the navigator range is changed.
         */
        this.navigatorFilter = new EventEmitter();
        this.redrawSlaves = false;
        this.hostClasses = ['k-chart', 'k-stockchart'];
        validatePackage(packageMetadata);
    }
    /**
     * If called, the navigator pane is not redrawn the next time the StockChart options are updated.
     * The method is useful if you need to update only the main series data for the selected period.
     */
    skipNavigatorRedraw() {
        this.redrawSlaves = true;
    }
    createInstance(element, observer) {
        this.applyNavigatorDefaults();
        if (this.isDevMode() && (this.options.zoomable || this.options.pannable)) {
            throw new Error('The pannable and zoomable options are not supported by the StockChart component.');
        }
        this.instance = new StockChart(element, this.options, this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    updateOptions() {
        this.applyNavigatorDefaults();
        if (this.redrawSlaves) {
            this.instance.applyOptions(this.options);
            this.instance.bindCategories();
            this.instance.navigator.redrawSlaves();
        }
        else {
            this.instance.setOptions(this.options);
        }
        this.redrawSlaves = false;
    }
    applyNavigatorDefaults() {
        this.options.navigator = Object.assign({}, this.options.navigator, NAVIGATOR_DEFAULTS);
    }
    isDevMode() {
        return isDevMode();
    }
}
StockChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartComponent, deps: [{ token: ConfigurationService }, { token: ThemeService }, { token: i0.ElementRef }, { token: i3.IntlService }, { token: i4.LocalizationService }, { token: i0.NgZone }, { token: StockInstanceEventService }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
StockChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: StockChartComponent, selector: "kendo-stockchart", inputs: { navigator: "navigator", pannable: "pannable", zoomable: "zoomable" }, outputs: { navigatorFilter: "navigatorFilter" }, providers: [
        ConfigurationService,
        TooltipTemplateService,
        { provide: RootConfigurationService, useExisting: ConfigurationService },
        StockInstanceEventService,
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.chart'
        }
    ], exportAs: ["kendoStockChart"], usesInheritance: true, ngImport: i0, template: `
        <div #surface class="k-chart-surface"></div>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    `, isInline: true, components: [{ type: CrosshairTooltipsContainerComponent, selector: "kendo-chart-crosshair-tooltips-container", inputs: ["popupSettings"] }, { type: TooltipPopupComponent, selector: "kendo-chart-tooltip-popup", inputs: ["animate", "classNames", "popupSettings", "wrapperClass"], outputs: ["leave"] }, { type: i8.ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'kendoStockChart',
                    providers: [
                        ConfigurationService,
                        TooltipTemplateService,
                        { provide: RootConfigurationService, useExisting: ConfigurationService },
                        StockInstanceEventService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.chart'
                        }
                    ],
                    selector: 'kendo-stockchart',
                    template: `
        <div #surface class="k-chart-surface"></div>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    `
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: i0.ElementRef }, { type: i3.IntlService }, { type: i4.LocalizationService }, { type: i0.NgZone }, { type: StockInstanceEventService }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { navigator: [{
                type: Input
            }], pannable: [{
                type: Input
            }], zoomable: [{
                type: Input
            }], navigatorFilter: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const PREFIX = new InjectionToken('configuration prefix');
/**
 * @hidden
 */
class PrefixConfigurationService extends ConfigurationService {
    constructor(rootService, prefix, ngZone) {
        super(ngZone);
        this.rootService = rootService;
        this.prefix = prefix;
    }
    push(store) {
        this.rootService.notify(new Change(this.prefix, store));
    }
    notify(change) {
        change.key = this.prefix + (change.key ? `.${change.key}` : '');
        this.rootService.notify(change);
    }
}
PrefixConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PrefixConfigurationService, deps: [{ token: RootConfigurationService }, { token: PREFIX }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
PrefixConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PrefixConfigurationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: PrefixConfigurationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: RootConfigurationService, decorators: [{
                        type: Inject,
                        args: [RootConfigurationService]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [PREFIX]
                    }] }, { type: i0.NgZone }];
    } });

/**
 * The configuration options of the navigator
 * ([see runnable example]({% slug overview_stockchart_charts %}#toc-navigator)).
 *
 * @example
 * ```ts-no-run
 * _@Component({
 *     selector: 'my-app',
 *       template: `
 *         <kendo-stockchart (navigatorFilter)="onNavigatorFilter($event)">
 *             <kendo-chart-series>
 *                <kendo-chart-series-item
 *                type="candlestick"
 *                 [data]="seriesData"
 *                 openField="Open"
 *                 closeField="Close"
 *                 lowField="Low"
 *                 highField="High"
 *                 categoryField="Date">
 *             </kendo-chart-series-item>
 *          </kendo-chart-series>
 *          <kendo-chart-navigator
 *            [categoryAxis]="categoryAxisOptions"
 *            [hint]="hintOptions"
 *            [pane]="paneOptions"
 *            [visible]="isVisible">
 *            <kendo-chart-navigator-select [from]="from" [to]="to">
 *            </kendo-chart-navigator-select>
 *            <kendo-chart-navigator-series>
 *              <kendo-chart-navigator-series-item type="area" [data]="navigatorData" field="Close" categoryField="Date">
 *              </kendo-chart-navigator-series-item>
 *           </kendo-chart-navigator-series>
 *          </kendo-chart-navigator>
 *        </kendo-stockchart>
 *        <br /><br />
 *        <button kendoButton (click)="isVisible = !isVisible">Toggle Navigator</button>
 *    `
 * })
 * ```
 */
class NavigatorComponent extends SettingsComponent {
    constructor(configurationService) {
        super('', configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorComponent, selector: "kendo-chart-navigator", inputs: { position: "position", visible: "visible", categoryAxis: "categoryAxis", hint: "hint", pane: "pane", select: "select", series: "series" }, providers: [{ provide: PREFIX, useValue: 'navigator' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: PREFIX, useValue: 'navigator' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }],
                    selector: 'kendo-chart-navigator',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { position: [{
                type: Input
            }], visible: [{
                type: Input
            }], categoryAxis: [{
                type: Input
            }], hint: [{
                type: Input
            }], pane: [{
                type: Input
            }], select: [{
                type: Input
            }], series: [{
                type: Input
            }] } });

/**
 * The configuration component of the navigator category axis.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-stockchart>
 *   <kendo-chart-navigator>
 *     <kendo-chart-navigator-category-axis
 *       color="maroon"
 *       [labels]="{color: 'green'}">
 *     </kendo-chart-navigator-category-axis>
 *   </kendo-chart-navigator>
 * </kendo-stockchart>
 * ```
 */
class NavigatorCategoryAxisComponent extends CategoryAxisItemComponent {
    constructor(configurationService, intl, localeId) {
        super(configurationService, null, intl, localeId);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisComponent, deps: [{ token: ConfigurationService }, { token: i3.IntlService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisComponent, selector: "kendo-chart-navigator-category-axis", providers: [{
            provide: PREFIX,
            useValue: 'navigator.categoryAxis'
        }, {
            provide: ConfigurationService,
            useClass: PrefixConfigurationService
        }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{
                            provide: PREFIX,
                            useValue: 'navigator.categoryAxis'
                        }, {
                            provide: ConfigurationService,
                            useClass: PrefixConfigurationService
                        }],
                    selector: 'kendo-chart-navigator-category-axis',
                    template: ''
                }]
        }], ctorParameters: function () {
        return [{ type: ConfigurationService }, { type: i3.IntlService }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [LOCALE_ID]
                    }] }];
    } });

/**
 * The configuration options of the crosshair.
 */
class NavigatorCategoryAxisCrosshairComponent extends CategoryAxisCrosshairComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisCrosshairComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisCrosshairComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisCrosshairComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisCrosshairComponent, selector: "kendo-chart-navigator-category-axis-crosshair", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisCrosshairComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-crosshair',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
class NavigatorCategoryAxisCrosshairTooltipComponent extends CategoryAxisCrosshairTooltipComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisCrosshairTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisCrosshairTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisCrosshairTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisCrosshairTooltipComponent, selector: "kendo-chart-navigator-category-axis-crosshair-tooltip", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisCrosshairTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-crosshair-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The configuration of the axis labels.
 */
class NavigatorCategoryAxisLabelsComponent extends CategoryAxisLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisLabelsComponent, selector: "kendo-chart-navigator-category-axis-labels", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The configuration of the category axis notes.
 */
class NavigatorCategoryAxisNotesComponent extends CategoryAxisNotesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisNotesComponent, selector: "kendo-chart-navigator-category-axis-notes", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The icon of the notes.
 */
class NavigatorCategoryAxisNotesIconComponent extends CategoryAxisNotesIconComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisNotesIconComponent, selector: "kendo-chart-navigator-category-axis-notes-icon", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The label of the notes.
 */
class NavigatorCategoryAxisNotesLabelComponent extends CategoryAxisNotesLabelComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisNotesLabelComponent, selector: "kendo-chart-navigator-category-axis-notes-label", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.
 * Categories with indexes in the range (`select.from`, `select.to`) will be selected.
 * This means that the last category in the range will not be included in the selection.
 * If the categories are dates, the range has also to be specified with date values.
 */
class NavigatorCategoryAxisSelectComponent extends CategoryAxisSelectComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisSelectComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisSelectComponent, selector: "kendo-chart-navigator-category-axis-select", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisSelectComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-select',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The title configuration of the navigator category axis.
 */
class NavigatorCategoryAxisTitleComponent extends CategoryAxisTitleComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorCategoryAxisTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorCategoryAxisTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorCategoryAxisTitleComponent, selector: "kendo-chart-navigator-category-axis-title", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorCategoryAxisTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-category-axis-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The default options of the navigator hint
 * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).
 */
class NavigatorHintComponent extends SettingsComponent {
    constructor(configurationService) {
        super('hint', configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorHintComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorHintComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorHintComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorHintComponent, selector: "kendo-chart-navigator-hint", inputs: { content: "content", format: "format", visible: "visible" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorHintComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-hint',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { content: [{
                type: Input
            }], format: [{
                type: Input
            }], visible: [{
                type: Input
            }] } });

/**
 * The configuration component of the navigator pane
 * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).
 */
class NavigatorPaneComponent extends PaneComponent {
    constructor(configurationService) {
        super(configurationService, null);
        this.configurationService = configurationService;
    }
}
NavigatorPaneComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorPaneComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorPaneComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorPaneComponent, selector: "kendo-chart-navigator-pane", providers: [{ provide: PREFIX, useValue: 'navigator.pane' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorPaneComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: PREFIX, useValue: 'navigator.pane' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }],
                    selector: 'kendo-chart-navigator-pane',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The title configuration of the StockChart navigator pane.
 */
class NavigatorPaneTitleComponent extends PanesTitleComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorPaneTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorPaneTitleComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorPaneTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorPaneTitleComponent, selector: "kendo-chart-navigator-pane-title", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorPaneTitleComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-pane-title',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * Specifies the initially selected range.
 * If no range is specified, the full range of values is rendered.
 */
class NavigatorSelectComponent extends SettingsComponent {
    constructor(configurationService) {
        super('select', configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSelectComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSelectComponent, selector: "kendo-chart-navigator-select", inputs: { from: "from", to: "to", mousewheel: "mousewheel" }, usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSelectComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-select',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; }, propDecorators: { from: [{
                type: Input
            }], to: [{
                type: Input
            }], mousewheel: [{
                type: Input
            }] } });

/**
 * The configuration component of a navigator series item
 * ([see example]({% slug navigator_stockchart_charts %})).
 */
class NavigatorSeriesItemComponent extends SeriesItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
NavigatorSeriesItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesItemComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesItemComponent, selector: "kendo-chart-navigator-series-item", providers: [ConfigurationService], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [ConfigurationService],
                    selector: 'kendo-chart-navigator-series-item',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }]; } });

/**
 * A collection of one or more navigator series items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-stockchart>
 *         <kendo-chart-navigator>
 *             <kendo-chart-navigator-series>
 *                 <kendo-chart-navigator-series-item type="area" [data]="data" field="value" categoryField="date">
 *                 </kendo-chart-navigator-series-item>
 *             </kendo-chart-navigator-series>
 *         </kendo-chart-navigator>
 *     </kendo-stockchart>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [];
 *
 *   constructor() {
 *      for (let idx = 0; idx < 100; idx++) {
 *          this.data.push({
 *              date: new Date(2017, 0, idx),
 *              value: Math.random() * 100
 *          });
 *      }
 *   }
 * }
 *
 * ```
 */
class NavigatorSeriesComponent extends SeriesComponent {
    constructor(configurationService, collectionService, tooltipTemplateService) {
        super(configurationService, collectionService, tooltipTemplateService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.tooltipTemplateService = tooltipTemplateService;
    }
    readTooltipTemplates() {
    }
}
NavigatorSeriesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesComponent, deps: [{ token: ConfigurationService }, { token: CollectionService }, { token: TooltipTemplateService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesComponent, selector: "kendo-chart-navigator-series", providers: [CollectionService], queries: [{ propertyName: "children", predicate: NavigatorSeriesItemComponent }], usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [CollectionService],
                    selector: 'kendo-chart-navigator-series',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: TooltipTemplateService }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [NavigatorSeriesItemComponent]
            }] } });

/**
 * The error bars of the StockChart navigator series.
 */
class NavigatorSeriesErrorBarsComponent extends SeriesErrorBarsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesErrorBarsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesErrorBarsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesErrorBarsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesErrorBarsComponent, selector: "kendo-chart-navigator-series-item-error-bars", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesErrorBarsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-error-bars',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The extremes configuration of the StockChart navigator series. Applies to extreme outliers.
 */
class NavigatorSeriesExtremesComponent extends SeriesExtremesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesExtremesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesExtremesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesExtremesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesExtremesComponent, selector: "kendo-chart-navigator-series-item-extremes", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesExtremesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-extremes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The configuration options of the StockChart series highlight.
 */
class NavigatorSeriesHighlightComponent extends SeriesHighlightComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesHighlightComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesHighlightComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesHighlightComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesHighlightComponent, selector: "kendo-chart-navigator-series-item-highlight", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesHighlightComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-highlight',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The label configuration of the StockChart navigator series.
 */
class NavigatorSeriesLabelsComponent extends SeriesLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
NavigatorSeriesLabelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesLabelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesLabelsComponent, selector: "kendo-chart-navigator-series-item-labels", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-labels',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The `from` label configuration of the StockChart navigator series.
 */
class NavigatorSeriesLabelsFromComponent extends SeriesLabelsFromComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
NavigatorSeriesLabelsFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsFromComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesLabelsFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesLabelsFromComponent, selector: "kendo-chart-navigator-series-item-labels-from", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsFromComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-labels-from',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The `to` label configuration of the StockChart navigator series.
 */
class NavigatorSeriesLabelsToComponent extends SeriesLabelsToComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
}
NavigatorSeriesLabelsToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsToComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesLabelsToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesLabelsToComponent, selector: "kendo-chart-navigator-series-item-labels-to", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesLabelsToComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-labels-to',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The marker configuration of the StockChart navigator series.
 */
class NavigatorSeriesMarkersComponent extends SeriesMarkersComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesMarkersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesMarkersComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesMarkersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesMarkersComponent, selector: "kendo-chart-navigator-series-item-markers", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesMarkersComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-markers',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The notes configuration of the StockChart navigator series.
 */
class NavigatorSeriesNotesComponent extends SeriesNotesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesNotesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesNotesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesNotesComponent, selector: "kendo-chart-navigator-series-item-notes", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-notes',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The icon of the notes.
 */
class NavigatorSeriesNotesIconComponent extends SeriesNotesIconComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesNotesIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesIconComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesNotesIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesNotesIconComponent, selector: "kendo-chart-navigator-series-item-notes-icon", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesIconComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-notes-icon',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The label of the notes.
 */
class NavigatorSeriesNotesLabelComponent extends SeriesNotesLabelComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesNotesLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesLabelComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesNotesLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesNotesLabelComponent, selector: "kendo-chart-navigator-series-item-notes-label", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesNotesLabelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-notes-label',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The outliers configuration of the StockChart navigator series. Applies to mild outliers.
 */
class NavigatorSeriesOutliersComponent extends SeriesOutliersComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesOutliersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesOutliersComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesOutliersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesOutliersComponent, selector: "kendo-chart-navigator-series-item-outliers", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesOutliersComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-outliers',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * The tooltip configuration of the StockChart navigator series.
 * The StockChart navigator series tooltip is displayed when the `navigator.series.tooltip.visible` option is set to `true`.
 */
class NavigatorSeriesTooltipComponent extends SeriesTooltipComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
}
NavigatorSeriesTooltipComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesTooltipComponent, deps: [{ token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Component });
NavigatorSeriesTooltipComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: NavigatorSeriesTooltipComponent, selector: "kendo-chart-navigator-series-item-tooltip", usesInheritance: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: NavigatorSeriesTooltipComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-chart-navigator-series-item-tooltip',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }]; } });

/**
 * @hidden
 */
const STOCK_CHART_DIRECTIVES = [
    StockChartComponent,
    NavigatorComponent,
    NavigatorCategoryAxisComponent,
    NavigatorCategoryAxisCrosshairComponent,
    NavigatorCategoryAxisCrosshairTooltipComponent,
    NavigatorCategoryAxisLabelsComponent,
    NavigatorCategoryAxisNotesComponent,
    NavigatorCategoryAxisNotesIconComponent,
    NavigatorCategoryAxisNotesLabelComponent,
    NavigatorCategoryAxisSelectComponent,
    NavigatorCategoryAxisTitleComponent,
    NavigatorHintComponent,
    NavigatorPaneComponent,
    NavigatorPaneTitleComponent,
    NavigatorSelectComponent,
    NavigatorSeriesComponent,
    NavigatorSeriesItemComponent,
    NavigatorSeriesErrorBarsComponent,
    NavigatorSeriesExtremesComponent,
    NavigatorSeriesHighlightComponent,
    NavigatorSeriesLabelsComponent,
    NavigatorSeriesLabelsFromComponent,
    NavigatorSeriesLabelsToComponent,
    NavigatorSeriesMarkersComponent,
    NavigatorSeriesNotesComponent,
    NavigatorSeriesNotesIconComponent,
    NavigatorSeriesNotesLabelComponent,
    NavigatorSeriesOutliersComponent,
    NavigatorSeriesTooltipComponent
];

/**
 * The root Chart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-sparkline [data]="data" type="column">
 *     </kendo-sparkline>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [
 *     936, 968, 1025, 999, 998, 1014, 1017, 1010, 1010, 1007,
 *     1004, 988, 990, 988, 987, 995, 946, 954, 991, 984,
 *     974, 956, 986, 936, 955, 1021, 1013, 1005, 958, 953,
 *     952, 940, 937, 980, 966, 965, 928, 916, 910, 980
 *   ];
 * }
 *
 * ```
 */
class SparklineComponent extends ChartComponent {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * @hidden
         */
        this.tooltipWrapperClass = 'k-sparkline-tooltip-wrapper';
        /**
         * @hidden
         */
        this.tooltipContentClasses = {
            'k-sparkline-tooltip': true
        };
        this.hostClasses = ['k-sparkline', 'k-widget'];
        validatePackage(packageMetadata);
    }
    createInstance(element, observer) {
        this.instance = new Sparkline(element, Sparkline.normalizeOptions(this.options), this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    updateOptions() {
        this.instance.setOptions(Sparkline.normalizeOptions(this.options));
    }
}
SparklineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineComponent, deps: [{ token: ConfigurationService }, { token: ThemeService }, { token: i0.ElementRef }, { token: i3.IntlService }, { token: i4.LocalizationService }, { token: i0.NgZone }, { token: InstanceEventService }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
SparklineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: SparklineComponent, selector: "kendo-sparkline", inputs: { type: "type", data: "data" }, providers: [
        ConfigurationService,
        TooltipTemplateService,
        InstanceEventService,
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.chart'
        }
    ], exportAs: ["kendoSparkline"], usesInheritance: true, ngImport: i0, template: `
        <span #surface class="k-chart-surface"></span>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup [animate]="false" [wrapperClass]="tooltipWrapperClass"
            [classNames]="tooltipContentClasses" (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    `, isInline: true, components: [{ type: CrosshairTooltipsContainerComponent, selector: "kendo-chart-crosshair-tooltips-container", inputs: ["popupSettings"] }, { type: TooltipPopupComponent, selector: "kendo-chart-tooltip-popup", inputs: ["animate", "classNames", "popupSettings", "wrapperClass"], outputs: ["leave"] }, { type: i8.ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'kendoSparkline',
                    providers: [
                        ConfigurationService,
                        TooltipTemplateService,
                        InstanceEventService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.chart'
                        }
                    ],
                    selector: 'kendo-sparkline',
                    template: `
        <span #surface class="k-chart-surface"></span>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup [animate]="false" [wrapperClass]="tooltipWrapperClass"
            [classNames]="tooltipContentClasses" (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    `
                }]
        }], ctorParameters: function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: i0.ElementRef }, { type: i3.IntlService }, { type: i4.LocalizationService }, { type: i0.NgZone }, { type: InstanceEventService }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { type: [{
                type: Input
            }], data: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const SPARKLINE_DIRECTIVES = [
    SparklineComponent
];

/**
 * A [module](link:site.data.urls.angular['ngmoduleapi']) that includes the Chart component and directives.
 *
 * Imports the ChartModule into your application
 * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity) or any other sub-module
 * that will use the Chart component.
  * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ChartModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, ChartModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class ChartModule {
}
ChartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ChartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartModule, declarations: [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SubtitleComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent], imports: [CommonModule, PopupModule, ResizeSensorModule], exports: [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SubtitleComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent] });
ChartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartModule, providers: [
        ThemeService
    ], imports: [[CommonModule, PopupModule, ResizeSensorModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [CHART_DIRECTIVES],
                    exports: [CHART_DIRECTIVES],
                    imports: [CommonModule, PopupModule, ResizeSensorModule],
                    providers: [
                        ThemeService
                    ]
                }]
        }] });

/**
 * A [module](link:site.data.urls.angular['ngmoduleapi']) that includes the StockChart component and directives.
 *
 * Imports the StockChartModule into your application
 * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity) or any other sub-module
 * that will use the StockChart component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { StockChartModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, StockChartModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class StockChartModule {
}
StockChartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StockChartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartModule, declarations: [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent], imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule], exports: [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, ChartModule] });
StockChartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartModule, imports: [[ChartModule, CommonModule, PopupModule, ResizeSensorModule], ChartModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: StockChartModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [STOCK_CHART_DIRECTIVES],
                    exports: [STOCK_CHART_DIRECTIVES, ChartModule],
                    imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule]
                }]
        }] });

/**
 * A [module](link:site.data.urls.angular['ngmoduleapi']) that includes the Sparkline component and directives.
 *
 * Imports the SparklineModule into your application
 * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity) or any other sub-module
 * that will use the Sparkline component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { SparklineModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, SparklineModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class SparklineModule {
}
SparklineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SparklineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineModule, declarations: [SparklineComponent], imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule], exports: [SparklineComponent, ChartModule] });
SparklineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineModule, imports: [[ChartModule, CommonModule, PopupModule, ResizeSensorModule], ChartModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: SparklineModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SPARKLINE_DIRECTIVES],
                    exports: [SPARKLINE_DIRECTIVES, ChartModule],
                    imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule]
                }]
        }] });

/**
 * A [module](link:site.data.urls.angular['ngmoduleapi']) that includes all Chart components and directives.
 *
 * Imports the ChartsModule into your application
 * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity) or any other sub-module
 * that will use the Charts components.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ChartsModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, ChartsModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class ChartsModule {
}
ChartsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ChartsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartsModule, exports: [ChartModule, SparklineModule, StockChartModule] });
ChartsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartsModule, imports: [ChartModule, SparklineModule, StockChartModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ChartsModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [ChartModule, SparklineModule, StockChartModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, AxisLabelClickEvent, CHART_DIRECTIVES, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisRangeLabelsComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, ChartComponent, ChartModule, ChartsModule, CollectionService, ConfigurationService, CrosshairTooltipComponent, CrosshairTooltipsContainerComponent, DonutCenterTemplateDirective, DragEndEvent, DragEvent, DragStartEvent, LegendComponent, LegendInactiveItemsComponent, LegendItemClickEvent, LegendItemComponent, LegendItemHoverEvent, LegendItemLeaveEvent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorComponent, NavigatorFilterEvent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesItemComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, NoteClickEvent, NoteHoverEvent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PaneRenderEvent, PanesComponent, PanesTitleComponent, PlotAreaClickEvent, PlotAreaComponent, PlotAreaHoverEvent, RenderEvent, SPARKLINE_DIRECTIVES, STOCK_CHART_DIRECTIVES, SelectEndEvent, SelectEvent, SelectStartEvent, SeriesClickEvent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesHoverEvent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, SparklineComponent, SparklineModule, StockChartComponent, StockChartModule, SubtitleComponent, TitleComponent, TooltipComponent, TooltipPopupComponent, TooltipTemplateService, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, WeekStartDay, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomEndEvent, ZoomEvent, ZoomStartEvent, ZoomableComponent };

